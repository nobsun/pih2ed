-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/nobsun/pih2ed#readme</a>
@package pih2ed
@version 0.11.2.0


-- | <tt>double (double)</tt> の結果を算出する別の計算方法を考えましょう．
module Ch01.Ex01

-- | 式
data Term
Num :: Int -> Term
Double :: Term -> Term
Add :: Term -> Term -> Term

-- | 簡約系列
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ print (redSeqs sample)
--   [double (double 2),(double 2) + (double 2),(2 + 2) + (double 2),4 + (double 2),4 + (2 + 2),4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(2 + 2) + (double 2),(2 + 2) + (2 + 2),4 + (2 + 2),4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(2 + 2) + (double 2),(2 + 2) + (2 + 2),(2 + 2) + 4,4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(double 2) + (2 + 2),(2 + 2) + (2 + 2),4 + (2 + 2),4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(double 2) + (2 + 2),(2 + 2) + (2 + 2),(2 + 2) + 4,4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(double 2) + (2 + 2),(double 2) + 4,(2 + 2) + 4,4 + 4,8]
--   [double (double 2),double (2 + 2),(2 + 2) + (2 + 2),4 + (2 + 2),4 + 4,8]
--   [double (double 2),double (2 + 2),(2 + 2) + (2 + 2),(2 + 2) + 4,4 + 4,8]
--   [double (double 2),double (2 + 2),double 4,4 + 4,8]
--   </pre>
redSeqs :: Term -> [[Term]]

-- | 1ステップ簡約
--   
--   <pre>
--   &gt;&gt;&gt; print (step sample)
--   [(double 2) + (double 2),double (2 + 2)]
--   </pre>
step :: Term -> [Term]
instance GHC.Show.Show Ch01.Ex01.Term


-- | <tt>x</tt> の値によらず <tt>sum [x] = x</tt> であることを示してください．
module Ch01.Ex02

-- | リストの要素の和
--   
--   <pre>
--   sum []     = 0           -- (1)
--   sum (n:ns) = n + sum ns  -- (2)
--   
--   </pre>
--   
--   <pre>
--   sum [x]
--   = { [x] ≡ (x:[]) }
--   sum (x:[])
--   = { sumの定義(2) }
--   x + sum []
--   = { sumの定義(1) }
--   x + 0
--   = { 0 は + の単位元 }
--   x
--   
--   </pre>
sum :: Num p => [p] -> p


-- | 数値のリストに対し積を計算する関数 <tt>product</tt> を定義し，<tt>product [2,3,4]</tt> =
--   <tt>24</tt> であることを示してください．
module Ch01.Ex03

-- | リストの要素の和
--   
--   <pre>
--   product []     = 1           -- (1)
--   product (n:ns) = n * sum ns  -- (2)
--   
--   </pre>
--   
--   <pre>
--   product [2,3,4]
--   = { [2,3,4] = (2:[3,4]) }
--   product (2:[3,4])
--   = { product の定義(2) }
--   2 * product [3,4]
--   = { [3,4] = (3:[4]) }
--   2 * product (3:[4])
--   = { product の定義(2) }
--   2 * (3 * product [4])
--   = { [4] = (4:[]) }
--   2 * (3 * product (4:[]))
--   = { product の定義(2) }
--   2 * (3 * (4 * product []))
--   = { product の定義(1) }
--   2 * (3 * (4 * 1))
--   = { 4 * 1 = 4 }
--   2 * (3 * 4)
--   = { 3 * 4 = 12 }
--   2 * 12
--   = { 2 * 12 = 12 }
--   24
--   
--   </pre>
product :: Num p => [p] -> p


-- | リストを降順に整列するように関数<tt>qsort</tt>の定義を変えるにはどうすればよいでしょうか？
module Ch01.Ex04

-- | 降順に整列
--   
--   <pre>
--   qsort []     = []                                    -- (1)
--   qsort (x:xs) = qsort larger ++ [x] ++ qsort smaller  -- (2) qsort smaller と qsort larger を交換
--     where
--       smaller = [a | a &lt;- xs, a &lt;= x]
--       larger  = [b | b <a>xs, b</a> x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; qsort [3,5,1,4,2]
--   [5,4,3,2,1]
--   </pre>
qsort :: Ord a => [a] -> [a]


-- | <tt>qsort</tt>の定義で，<tt>&lt;=</tt> を <tt>&lt;</tt>
--   に置き換えるとどのような影響があるでしょうか？
module Ch01.Ex05

-- | <pre>
--   qsort []     = []                                    -- (1)
--   qsort (x:xs) = qsort smaller ++ [x] ++ qsort larger  -- (2)
--     where
--       smaller = [a | a &lt;- xs, a &lt; x] -- <tt>&lt;=</tt> を <tt>&lt;</tt> に置き換える
--       larger  = [b | b <a>xs, b</a> x]
--   </pre>
--   
--   <tt>qsort</tt>の定義で，<tt>&lt;=</tt> を <tt>&lt;</tt>
--   に置き換えると，ピボットとと同値のピボット以外の要素を落してしまうことになる．
--   
--   <pre>
--   &gt;&gt;&gt; qsort [2,2,3,1,1]
--   [1,2,3]
--   </pre>
qsort :: Ord a => [a] -> [a]


-- | この章の例題をGHCiを用いて実行してください
module Ch02.Ex01


-- | 次の式に結合順位を示す括弧を付けてください．
module Ch02.Ex02


-- | 以下のプログラムにはエラーが三つあります．エラーを修正してGHCiで正しく動くか確かめてください．
module Ch02.Ex03

-- | プログラムの修正
--   
--   <pre>
--   N =  a <a>div</a> length xs     -- (1)変数名は小文字アルファベット．(2)関数<tt>div</tt>を中置演算子に変更するには<tt>`</tt>で囲む．
--        where
--            a = 10
--           xs = [1,2,3,4,5]   -- (3)同一レベルのバインディングでは左辺のインデント位置を同じにする．
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; n
--   2
--   </pre>
n :: Int


-- | プレリュード関数 <tt>last</tt> は，空でないリストの最後の要素を取り出します． たとえば，<tt>last
--   [1,2,3,4,5]</tt> = <tt>5</tt> です． この章で紹介したプレリュード関数を使って，関数
--   <tt>last</tt> を定義してください． さらに別の定義も考えてみてください．
module Ch02.Ex04

-- | <tt>last</tt> の定義
--   
--   <pre>
--   last' (x:[]) = x
--   last' (_:xs) = last' xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last' [1,2,3,4,5]
--   5
--   </pre>
last' :: () => [p] -> p

-- | もう一つの <tt>last</tt> の定義
--   
--   <pre>
--   last'' = head . reverse
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last'' [1,2,3,4,5]
--   5
--   </pre>
last'' :: () => [c] -> c


-- | プレリュード関数 <tt>init</tt> は，空でないリストから最後の要素を取り除きます． たとえば，<tt>init
--   [1,2,3,4,5]</tt> = <tt>[1,2,3,4]</tt> です．関数 <tt>init</tt>
--   の定義を二通り示してください．
module Ch02.Ex05

-- | <tt>init</tt> の一つめの定義
--   
--   <pre>
--   init' (x:[]) = []
--   init' (x:xs) = x : init' xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init' [1,2,3,4,5]
--   [1,2,3,4]
--   </pre>
init' :: () => [a] -> [a]

-- | <tt>init</tt> のもう一つの定義
--   
--   <pre>
--   init'' = reverse . tail . reverse
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init'' [1,2,3,4,5]
--   [1,2,3,4]
--   </pre>
init'' :: () => [a] -> [a]


-- | 以下の値の型は何でしょう?
--   
--   <pre>
--   <a>'a','b','c'</a>
--   [(False,'0'),(True,'1')]
--   ([False,True],['0','1'])
--   [tail, init, reverse]
--   </pre>
module Ch03.Ex01


-- | 以下の関数の定義を書き下してください．型が正しい限り，どのように実装してもかまいません．
--   
--   <pre>
--   bools :: [Bool]
--   nums :: [[Int]]
--   add :: Int -&gt; Int -&gt; Int -&gt; Int
--   copy :: a -&gt; (a, a)
--   apply :: (a -&gt; b) -&gt; a -&gt; b
--   </pre>
module Ch03.Ex02

-- | <pre>
--   &gt;&gt;&gt; :type bools
--   bools :: [Bool]
--   </pre>
bools :: [Bool]

-- | <pre>
--   &gt;&gt;&gt; :type nums
--   nums :: [[Int]]
--   </pre>
nums :: [[Int]]

-- | <pre>
--   &gt;&gt;&gt; :type add
--   add :: Int -&gt; Int -&gt; Int -&gt; Int
--   </pre>
add :: Int -> Int -> Int -> Int

-- | <pre>
--   &gt;&gt;&gt; :type copy
--   copy :: a -&gt; (a, a)
--   </pre>
copy :: a -> (a, a)

-- | <pre>
--   &gt;&gt;&gt; :type apply
--   apply :: (a -&gt; b) -&gt; a -&gt; b
--   </pre>
apply :: (a -> b) -> a -> b


-- | 以下の関数の型は何でしょう?
--   
--   <pre>
--   second xs = head (tail xs)
--   swap (x,y) = (y,x)
--   pair x y = (x,y)
--   double x = x*2
--   palindrome xs = reverse xs == xs
--   twice f x = f (f x)
--   </pre>
module Ch03.Ex03

-- | <pre>
--   &gt;&gt;&gt; :type second
--   second :: [a] -&gt; a
--   </pre>
second :: [a] -> a

-- | <pre>
--   &gt;&gt;&gt; :type swap
--   swap :: (a, b) -&gt; (b, a)
--   </pre>
swap :: (a, b) -> (b, a)

-- | <pre>
--   &gt;&gt;&gt; :type pair
--   pair :: a -&gt; b -&gt; (a, b)
--   </pre>
pair :: a -> b -> (a, b)

-- | <pre>
--   &gt;&gt;&gt; :type double
--   double :: Num a =&gt; a -&gt; a
--   </pre>
double :: Num a => a -> a

-- | <pre>
--   &gt;&gt;&gt; :type palindrome
--   palindrome :: Eq a =&gt; [a] -&gt; Bool
--   </pre>
palindrome :: Eq a => [a] -> Bool

-- | <pre>
--   &gt;&gt;&gt; :type twice
--   twice :: (a -&gt; a) -&gt; a -&gt; a
--   </pre>
twice :: (a -> a) -> a -> a


-- | 上記三つの問題の答えを GHCi を使って確かめてください．
--   
--   <pre>
--   Ch03ex01.hs
--   Ch03ex02.hs
--   Ch03ex03.hs
--   </pre>
module Ch03.Ex04


-- | 一般的に，関数の型を Eq クラスのインスタンスにするのが実現不可能な理由は何でしょうか? 実現可能なのはどういった場合でしょうか?
--   
--   関数の等値性は，外延的等値性を確認することになるが， 関数の域(domain)を網羅列挙して確認することは一般にはできない．
--   ただし，域が現実的に網羅列挙可能であれば Eq クラスのインスタンスにできる．
module Ch03.Ex05


-- | プレリュード関数を使って，長さが偶数のリストを半分ずつに分割する関数 <tt>halve :: [a] -&gt; ([a],
--   [a])</tt> を定義してください．
module Ch04.Ex01

-- | 長さ偶数のリストを半分ずつに分割する．
--   
--   <pre>
--   &gt;&gt;&gt; halve [1,2,3,4,5,6]
--   ([1,2,3],[4,5,6])
--   </pre>
halve :: [a] -> ([a], [a])


-- | リストの三つめの要素を返す関数 <tt>third :: [a] -&gt; a</tt> を以下を使ってそれぞれ定義してください．
--   ただし，リストには三つ以上の要素が格納されているとします．
--   
--   <ul>
--   <li>a. head と tail</li>
--   <li>b. リストのインデックス演算子 !!</li>
--   <li>c. パターンマッチ</li>
--   </ul>
module Ch04.Ex02

-- | リストの三つめの要素 その1
--   
--   <pre>
--   third1 :: [a] -&gt; a
--   third1 = head . tail . tail
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; third1 [1,2,3,4,5,6]
--   3
--   </pre>
third1 :: [a] -> a

-- | リストの三つめの要素 その2
--   
--   <pre>
--   third2 :: [a] -&gt; a
--   third2 = (!! 2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; third2 [1,2,3,4,5,6]
--   3
--   </pre>
third2 :: [a] -> a

-- | リストの三つめの要素 その3
--   
--   <pre>
--   third3 :: [a] -&gt; a
--   third3 (_:_:x:_) = x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; third3 [1,2,3,4,5,6]
--   3
--   </pre>
third3 :: [a] -> a


-- | プレリュード関数 tail のように振る舞う safetail :: [a] -&gt; [a] 関数を考えてください．
--   ただし，<tt>tail</tt> は空リストを与えるとエラーになりますが， <tt>safetail</tt>
--   は空リストをエラーとせず，空リストを返すものとします．
--   
--   <ul>
--   <li>a. 条件式</li>
--   <li>b. ガード付きの等式</li>
--   <li>c. パターンマッチ</li>
--   </ul>
module Ch04.Ex03

-- | 安全な <tt>tail</tt> その1
--   
--   <pre>
--   safetail1 :: [a] -&gt; [a]
--   safetail1 xs = if null xs then xs else tail xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safetail1 [1,2,3]
--   [2,3]
--   
--   &gt;&gt;&gt; safetail1 []
--   []
--   </pre>
safetail1 :: [a] -> [a]

-- | 安全な <tt>tail</tt> その2
--   
--   <pre>
--   safetail2 :: [a] -&gt; [a]
--   safetail2 xs
--     | null xs   = xs
--     | otherwise = tail xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safetail2 [1,2,3]
--   [2,3]
--   
--   &gt;&gt;&gt; safetail2 []
--   []
--   </pre>
safetail2 :: [a] -> [a]

-- | 安全な <tt>tail</tt> その3
--   
--   <pre>
--   safetail3 :: [a] -&gt; [a]
--   safetail3 []     = []
--   safetail3 (_:xs) = xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safetail3 [1,2,3]
--   [2,3]
--   
--   &gt;&gt;&gt; safetail3 []
--   []
--   </pre>
safetail3 :: [a] -> [a]


-- | 論理積演算子 &amp;&amp; と同様に，パターンマッチを使って論理和演算子 <tt>||</tt> を四通りの方法で定義してください．
module Ch04.Ex04

-- | 1つめの定義
--   
--   <pre>
--   def1 :: Bool -&gt; Bool -&gt; Bool
--   def1 = (||)
--     where
--       False || False = False
--       False || True  = True
--       True  || False = True
--       True  || True  = True
--   </pre>
def1 :: Bool -> Bool -> Bool

-- | 2つめの定義
--   
--   <pre>
--   def2 :: Bool -&gt; Bool -&gt; Bool
--   def2 = (||)
--     where
--       False || False = False
--       _     || _     = True
--   </pre>
def2 :: Bool -> Bool -> Bool

-- | 3つめの定義
--   
--   <pre>
--   def3 :: Bool -&gt; Bool -&gt; Bool
--   def3 = (||)
--     where
--       False || b = b
--       True  || _ = True
--   </pre>
def3 :: Bool -> Bool -> Bool

-- | 4つめの定義
--   
--   <pre>
--   def4 :: Bool -&gt; Bool -&gt; Bool
--   def4 = (||)
--     where
--       False || b = b
--       True  || _ = True
--   </pre>
def4 :: Bool -> Bool -> Bool


-- | 他のプレリュード関数や演算子を使わずに，論理積 <tt>&amp;&amp;</tt>
--   に対する以下の定義を条件式を用いて形式化してください．
--   
--   <pre>
--   True &amp;&amp; True = True
--   _    &amp;&amp; _    = False
--   </pre>
module Ch04.Ex05

-- | 連言の条件式を使った定式化
--   
--   <pre>
--   (&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool
--   p &amp;&amp; q = if p then if q then True else false else false
--   </pre>
(&&) :: Bool -> Bool -> Bool


-- | 他のプレリュード関数や演算子を使わずに，論理積 <tt>&amp;&amp;</tt>
--   に対する以下の定義を条件式を用いて形式化してください．
--   
--   <pre>
--   True  &amp;&amp; b = b
--   False &amp;&amp; _ = False
--   </pre>
module Ch04.Ex06

-- | 連言の条件式を使った定式化
--   
--   <pre>
--   (&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool
--   p &amp;&amp; q = if p then q else False
--   </pre>
(&&) :: Bool -> Bool -> Bool


-- | 以下のカリー化された関数の定義の意味をラムダ式を用いて形式化してください．
--   
--   <pre>
--   mult :: Int -&gt; Int -&gt; Int -&gt; Int
--   mult x y z = x * y * z
--   </pre>
module Ch04.Ex07

-- | 3つの整数の積
--   
--   <pre>
--   mult :: Int -&gt; Int -&gt; Int -&gt; Int
--   mult =  x -&gt;  y -&gt;  z -&gt; x * y * z
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mult 2 3 4
--   24
--   </pre>
mult :: Int -> Int -> Int -> Int


-- | Luhn アルゴリズム
--   
--   <ul>
--   <li>それぞれの桁を独立した数だとみなす</li>
--   <li>右から数えて偶数番めの数すべてを二倍にする</li>
--   <li>それぞれの数が 9 より大きいなら 9 を引く</li>
--   <li>すべての数を足し合わせる</li>
--   <li>合計が 10 で割り切れるなら、カードの番号は正しい</li>
--   </ul>
module Ch04.Ex08

-- | 数を 2 倍にして、もしその結果が 9 より大きいなら 9 を引く関数
--   
--   <pre>
--   &gt;&gt;&gt; luhnDouble 3
--   6
--   
--   &gt;&gt;&gt; luhnDouble 6
--   3
--   </pre>
luhnDouble :: Int -> Int

-- | 4桁の銀行カード番号が正しいかどうかを判定する関数
--   
--   <pre>
--   &gt;&gt;&gt; luhn 1 7 8 4
--   True
--   
--   &gt;&gt;&gt; luhn 4 7 8 3
--   False
--   </pre>
luhn :: Int -> Int -> Int -> Int -> Bool


-- | リスト内包表記を使って， 1 から 100 までの二乗の和 1^2 + 2^2 + ... + 100^2 を計算する式を考えてください．
module Ch05.Ex01

-- | 2乗の和
sumSquare :: [Int] -> Int


-- | m × n の座標格子が， 0 ≦ x ≦ m ， 0 ≦ y ≦ n に対し， すべての整数の組 (x, y) で表現されているとします．
--   リスト内包表記を一つ用いて，与えられた大きさの座標格子を返す関数 <tt>grid :: Int -&gt; Int -&gt;
--   [(Int,Int)]</tt> を定義してください．
module Ch05.Ex02

-- | 格子点
--   
--   <pre>
--   &gt;&gt;&gt; grid 1 2
--   [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]
--   </pre>
grid :: Int -> Int -> [(Int, Int)]


-- | リスト内容表記一つと上記の関数 grid を用いて，大きさ n の正方形座標を 返す関数 square :: Int -&gt;
--   [(Int,Int)] を定義してください． ただし，(0, 0) から (n, n) の対角の格子は含みません．
module Ch05.Ex03

-- | 対角格子を抜いた正方格子
--   
--   <pre>
--   &gt;&gt;&gt; square 2
--   [(0,1),(0,2),(1,0),(1,2),(2,0),(2,1)]
--   </pre>
square :: Int -> [(Int, Int)]
grid :: Int -> Int -> [(Int, Int)]


-- | ある要素のみからなるリストを生成するプレリュード関数 <tt>replicate :: Int -&gt; a -&gt; [a]</tt>
--   を関数 <tt>length</tt> と同じ要領でリスト内包表記を用いて定義してください.
module Ch05.Ex04

-- | 同一要素を指定した個数含むリストの生成
--   
--   <pre>
--   &gt;&gt;&gt; replicate 3 True
--   [True,True,True]
--   </pre>
replicate :: Int -> a -> [a]


-- | <tt> x^2 + y^2 = z^2 </tt> を満たす正の整数をピタゴラス数と呼び，三つ組 <tt>(x, y, z)</tt>
--   で表します． ピタゴラス数のリストを生成する関数 <tt> pyths :: Int -&gt; [(Int, Int, Int)]
--   </tt>をリスト内包表記を使って定義してください． ただし、ピタゴラス数の要素は与えられた上限以下であるとします．
module Ch05.Ex05

-- | ピタゴラス数
--   
--   <pre>
--   &gt;&gt;&gt; pyths 10
--   [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
--   </pre>
pyths :: Int -> [(Int, Int, Int)]


-- | 自分自身を除く約数の和が自分自身と等しいとき，その整数を完全数と呼びます． 与えられた上限までに含まれる完全数すべてを算出する関数
--   <tt>perfects :: Int -&gt; [Int]</tt> を リスト内包表記と関数 factors
--   を使って定義してください．
module Ch05.Ex06

-- | 完全数
--   
--   <pre>
--   &gt;&gt;&gt; perfects 500
--   [6,28,496]
--   </pre>
perfects :: Int -> [Int]

-- | 素因数
factors :: Int -> [Int]


-- | 二つの生成器を持つリスト内包表記 <tt>[(x, y) | x &lt;- [1, 2, 3], y &lt;- [4, 5,
--   6]]</tt> は， 一つの生成器を持つリスト内包表記二つでも表現できることを示してください．
module Ch05.Ex07


-- | 関数 <tt>positions</tt> を関数 <tt>find</tt> を使って再定義してください．
module Ch05.Ex08

-- | <tt>find</tt> を用いた <tt>positions</tt> の定義
--   
--   <pre>
--   positions :: Eq a =&gt; a -&gt; [a] -&gt; [Int]
--   positions x = find x . flip zip [0..]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; positions False [True, False, True, False]
--   [1,3]
--   </pre>
positions :: Eq a => a -> [a] -> [Int]
find :: Eq a => a -> [(a, b)] -> [b]


-- | 二つのリストから内積を計算する関数 <tt>scalarproduct :: [Int] -&gt; [Int] -&gt;
--   Int</tt> を 関数 <tt>chisqr</tt> と同じようにリスト内包表記を使って定義できることを示してください．
module Ch05.Ex09

-- | 内積
--   
--   <pre>
--   scalarproduct :: [Int] -&gt; [Int] -&gt; Int
--   scalarproduct xs ys = sum [ x * y | (x, y) &lt;- zip xs ys ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scalarproduct [1,2,3] [4,5,6]
--   32
--   </pre>
scalarproduct :: [Int] -> [Int] -> Int


-- | シーザー暗号のプログラムを変更して大文字も扱えるようにしてください．
module Ch05.Ex10

-- | 文字を整数に変換 'a' -&gt; 0，'b' -&gt; 1，... ，'A' -&gt; 26，'B' -&gt; 27
--   
--   <pre>
--   &gt;&gt;&gt; let2int 'a'
--   0
--   
--   &gt;&gt;&gt; let2int 'B'
--   27
--   </pre>
let2int :: Char -> Int

-- | 整数を文字に変換 0 -&gt; 'a'，1 -&gt; 'b'，...，26 -&gt; 'A'，27 -&gt; 'B'
--   
--   <pre>
--   &gt;&gt;&gt; int2let 1
--   'b'
--   
--   &gt;&gt;&gt; int2let 26
--   'A'
--   </pre>
int2let :: Int -> Char

-- | アルファベット文字シフト
--   
--   <pre>
--   &gt;&gt;&gt; shift 3 'a'
--   'd'
--   
--   &gt;&gt;&gt; shift 3 'z'
--   'c'
--   
--   &gt;&gt;&gt; shift (-3) 'c'
--   'z'
--   
--   &gt;&gt;&gt; shift 3 ' '
--   ' '
--   
--   &gt;&gt;&gt; shift 3 'A'
--   'D'
--   
--   &gt;&gt;&gt; shift 3 'Z'
--   'C'
--   
--   &gt;&gt;&gt; shift (-3) 'C'
--   'Z'
--   </pre>
shift :: Int -> Char -> Char

-- | 暗号
--   
--   <pre>
--   &gt;&gt;&gt; encode 3 "Haskell is fun"
--   "Kdvnhoo lv ixq"
--   
--   &gt;&gt;&gt; encode (-3) "Kdvnhoo lv ixq"
--   "Haskell is fun"
--   </pre>
encode :: Int -> String -> String


-- | 再帰的に定義された階乗関数は， (-1) のように負の整数を与えられた場合，どのように振る舞うでしょうか?
--   再帰部にガードを加えることで，負の整数を禁止するように定義を変更してください．
module Ch06.Ex01

-- | 階乗関数
--   
--   <pre>
--   fac :: Int -&gt; Int
--   fac 0 = 1
--   fac n | n &lt; 0     = error "<a>fac</a> must be applied to non-negative number"
--         | otherwise = n * fac (n - 1)
--   </pre>
fac :: Int -> Int


-- | 与えられた非負の整数から <tt>0</tt> までを足し合わせる関数 <tt>sumdown :: Int -&gt; Int </tt>
--   を再帰的に定義してください． たとえば，<tt>sumdown 3</tt> は <tt>3+2+1+0</tt> の結果
--   <tt>6</tt> を返します．
module Ch06.Ex02

-- | 与えられた非負の整数から <tt>0</tt> までを足し合わせる．
--   
--   <pre>
--   &gt;&gt;&gt; sumdown 3
--   6
--   </pre>
sumdown :: Int -> Int


-- | 乗算演算子 <tt>*</tt> の再帰を参考にして，負でない整数に対する冪乗演算子 <tt>^</tt> を定義
--   してください．また，その定義を使って <tt>2 ^ 3</tt> を簡約してください．
module Ch06.Ex03

-- | べき乗演算子
--   
--   <pre>
--   m ^ 0 = 1                  -- (1)
--   m ^ n = m * (m ^ (n - 1))  -- (2)
--   </pre>
--   
--   <pre>
--     2 ^ 3
--   = { (2) }
--     2 * (2 ^ 2)
--   = { (2) }
--     2 * (2 * (2 ^ 1))
--   = { (2) }
--     2 * (2 * (2 * (2 ^ 0)))
--   = { (1) }
--     2 * (2 * (2 * 1))
--   = { (*) }
--     2 * (2 * 2)
--   = { (*) }
--     2 * 4
--   = { (*) }
--     8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 ^ 3
--   8
--   </pre>
(^) :: Int -> Int -> Int
infixr 8 ^


-- | 二つの非負の整数に対する最大公約数を計算するために，ユークリッドの互除法を実現する関数 <tt> euclid :: Int -&gt;
--   Int -&gt; Int </tt> を再帰的に定義してください．
module Ch06.Ex04

-- | ユークリッド互除法
--   
--   <pre>
--   &gt;&gt;&gt; euclid 6 27
--   3
--   </pre>
euclid :: Int -> Int -> Int


-- | この章で与えられた再帰的定義を使って，<tt>length [1,2,3]</tt>，<tt>drop 3
--   [1,2,3,4,5]</tt>，<tt>init [1,2,3]</tt> を簡約してください．
module Ch06.Ex05

-- | リストの長さ <tt> length :: [a] -&gt; Int length [] = 0 -- (1) length (_:xs)
--   = 1 + length xs -- (2) </tt>
--   
--   <pre>
--     length [1,2,3]
--   = { (2) }
--     1 + (length [2,3])
--   = { (2) }
--     1 + (1 + (length [3]))
--   = { (2) }
--     1 + (1 + (1 + lenght []))
--   = { (1) }
--     1 + (1 + (1 + 0))
--   = { (+) }
--     1 + (1 + 1)
--   = { (+) }
--     1 + 2
--   = { (+) }
--     3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length [1,2,3]
--   3
--   </pre>
length :: [a] -> Int

-- | リストの先頭から指定した数の要素を落す
--   
--   <pre>
--   drop :: Int -&gt; [a] -&gt; [a]
--   drop 0 xs     = xs            -- (1)
--   drop _ []     = []            -- (2)
--   drop n (_:xs) = drop (n-1) xs -- (3)
--   </pre>
--   
--   <pre>
--     drop 3 [1,2,3,4,5]
--   = { (3) }
--     drop 2 [2,3,4,5]
--   = { (3) }
--     drop 1 [3,4,5]
--   = { (3) }
--     drop 0 [4,5]
--   = { (1) }
--     [4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   </pre>
drop :: Int -> [a] -> [a]

-- | リストの先頭部分
--   
--   <pre>
--   init :: [a] -&gt; [a]
--   init [_]    = []          -- (1)
--   init (x:xs) = x : init xs -- (2)
--   </pre>
--   
--   <pre>
--     init [1,2,3]
--   = { (2) }
--     1 : init [2,3]
--   = { (2) }
--     1 : (2 : init [3])
--   = { (1) }
--     1 : (2 : [])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init [1,2,3]
--   [1,2]
--   </pre>
init :: [a] -> [a]


-- | プレリュードを見ないで，リストに対する以下のプレリュード関数を再帰を使って定義してください．
--   
--   a. リストの要素がすべて True であるか検査する関数 <tt>and :: [Bool] -&gt; Bool</tt>
--   
--   b. リストのリストを取り，要素であるリストを連結する関数 <tt>concat :: [[a]] -&gt; [a]</tt>
--   
--   c. 指定された要素を n 個持つリストを生成する関数 <tt>replicate :: Int -&gt; a -&gt;
--   [a]</tt>
--   
--   d. 空でないリストの n 番めの要素を取り出す関数 <tt>(!!) :: [a] -&gt; Int -&gt; a</tt>
--   
--   e. リストの要素に含まれるか検査する関数 <tt>elem :: Eq a =&gt; a -&gt; [a] -&gt;
--   Bool</tt>
module Ch06.Ex06

-- | リストの要素がすべて True であるか検査する関数
and :: [Bool] -> Bool

-- | リストのリストを取り，要素であるリストを連結する関数
concat :: [[a]] -> [a]

-- | 指定された要素を n 個持つリストを生成する関数
replicate :: Int -> a -> [a]

-- | 空でないリストの n 番めの要素を取り出す関数
(!!) :: [a] -> Int -> a

-- | リストの要素に含まれるか検査する関数
elem :: Eq a => a -> [a] -> Bool


-- | 関数 <tt>merge :: Ord a =&gt; [a] -&gt; [a] -&gt; [a]</tt>
--   は，整列されたリストを二つ取り，一つの整列されたリストにして返す関数です． 以下に使用例を示します．
--   
--   <pre>
--   &gt; merge [2,5,6] [1,3,4]
--   [1,2,3,4,5,6]
--   </pre>
--   
--   関数 <tt>merge</tt> を再帰を用いて定義してください．ただし，関数 <tt>insert</tt> や
--   <tt>isort</tt>など， 整列されたリストを処理する関数は利用してはいけません．
module Ch06.Ex07

-- | 整列されたリストを二つ取り，一つの整列されたリストにして返す関数
--   
--   <pre>
--   &gt;&gt;&gt; merge [2,5,6] [1,3,4]
--   [1,2,3,4,5,6]
--   </pre>
merge :: Ord a => [a] -> [a] -> [a]


-- | 関数 <tt>merge</tt> を使って，マージソートを実行する関数 <tt>msort :: Ord a =&gt; [a]
--   -&gt; [a]</tt> を定義してください．
--   マージソートは，引数のリストを二つに分割し，それぞれを整列した後で再び一つに戻すことで整列を実現します．
--   ただし，空リストと要素が一つのリストはすでに整列されていると考えます．
module Ch06.Ex08

-- | マージソート
--   
--   <pre>
--   &gt;&gt;&gt; msort [3,2,1,4]
--   [1,2,3,4]
--   </pre>
msort :: Ord a => [a] -> [a]
halve :: [a] -> ([a], [a])


-- | 五段階の工程を使って，以下のプレリュード関数を定義してください．
--   
--   a. 数値のリストに対し要素の和を計算する関数 <tt>sum</tt>
--   
--   b. リストの先頭から <tt>n</tt> 個の要素を取り出す関数 <tt>take</tt>
--   
--   c. 空でないリストの末尾の要素を取り出す関数 <tt>last</tt>
module Ch06.Ex09

-- | 数値のリストに対し要素の和を計算する関数
--   
--   <ol>
--   <li><pre> sum :: [Int] -&gt; Int </pre></li>
--   <li><pre> sum :: [Int] -&gt; Int sum [] = sum (x:xs) = </pre></li>
--   <li><pre> sum :: [Int] -&gt; Int sum [] = 0 sum (x:xs) = </pre></li>
--   <li><pre> sum :: [Int] -&gt; Int sum [] = 0 sum (x:xs) = x + sum xs
--   </pre></li>
--   <li><pre> sum :: Num a =&gt; [a] -&gt; a sum [] = 0 sum (x:xs) = x +
--   sum xs </pre></li>
--   </ol>
sum :: Num a => [a] -> a

-- | リストの先頭から <tt>n</tt> 個の要素を取り出す関数
--   
--   <ol>
--   <li><pre> take :: Int -&gt; [a] -&gt; [a] </pre></li>
--   <li><pre> take :: Int -&gt; [a] -&gt; [a] take 0 [] = take 0 (x:xs) =
--   take n [] = take n (x:xs) = </pre></li>
--   <li><pre> take :: Int -&gt; [a] -&gt; [a] take 0 [] = [] take 0 (x:xs)
--   = [] take n [] = take n (x:xs) = </pre></li>
--   <li><pre> take :: Int -&gt; [a] -&gt; [a] take 0 [] = [] take 0 (x:xs)
--   = [] take n [] = [] take n (x:xs) = x : take (n-1) xs </pre></li>
--   <li><pre> take :: Int -&gt; [a] -&gt; [a] take 0 _ = [] take _ [] = []
--   take n (x:xs) = x : take (n-1) xs </pre></li>
--   </ol>
take :: Int -> [a] -> [a]

-- | 空でないリストの末尾の要素を取り出す関数
--   
--   <ol>
--   <li><pre> last :: [a] -&gt; a </pre></li>
--   <li><pre> last :: [a] -&gt; a last (x:xs) = </pre></li>
--   <li><pre> last :: [a] -&gt; a last (x:xs) | null xs = x | otherwsie =
--   </pre></li>
--   <li><pre> last :: [a] -&gt; a last (x:xs) | null xs = x | otherwsie =
--   last xs </pre></li>
--   <li><pre> last :: [a] -&gt; a last [x] = x last (x:xs) = last xs
--   </pre></li>
--   </ol>
last :: [a] -> a


-- | リスト内包表記 <tt>[f x | x &lt;- xs, p x]</tt> は，高階関数 <tt>map</tt> と
--   <tt>filter</tt> を使ってどう書き直せるでしょうか．
--   
--   <pre>
--   map f (filter p xs)
--   </pre>
module Ch07.Ex01


-- | プレリュードでの定義を見ないで以下の高階関数を定義してください．
--   
--   a. リストの要素のすべてが述語を満たすか検査する関数 <tt> all :: (a -&gt; Bool) -&gt; [a] -&gt;
--   Bool </tt>
--   
--   b. リストの要素のどれかが述語を満たすか検査する関数 <tt> any :: (a -&gt; Bool) -&gt; [a] -&gt;
--   Bool </tt>
--   
--   c. リストの先頭から述語を満たす連続した要素を取り出す関数 <tt> takeWhile :: (a -&gt; Bool) -&gt;
--   [a] -&gt; [a] </tt>
--   
--   d. リストの先頭から述語を満たす連続した要素を取り除く関数 <tt> dropWhile :: (a -&gt; Bool) -&gt;
--   [a] -&gt; [a] </tt>
module Ch07.Ex02

-- | リストの要素のすべてが述語を満たすか検査する関数
--   
--   <pre>
--   all :: (a -&gt; Bool) -&gt; [a] -&gt; Bool
--   all p = foldr ((&amp;&amp;) . p) True
--   </pre>
all :: (a -> Bool) -> [a] -> Bool

-- | リストの要素のどれかが述語を満たすか検査する関数
--   
--   <pre>
--   any p = foldr ((||) . p) False
--   </pre>
any :: (a -> Bool) -> [a] -> Bool

-- | リストの先頭から述語を満たす連続した要素を取り出す関数
--   
--   <pre>
--   takeWhile p = foldr φ []
--     where
--       φ x xs | p x       = x : xs
--               | otherwise = []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | リストの先頭から述語を満たす連続した要素を取り除く関数
--   
--   <pre>
--   dropWhile p = para φ []
--     where
--       φ x (xs, ys)
--         | p x       = ys
--         | otherwise = x:xs
--   
--   para :: (a -&gt; ([a], b) -&gt; b) -&gt; b -&gt; [a] -&gt; b
--   para _  z []     = z
--   para φ z (x:xs) = φ x (xs, para φ z xs)
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]
para :: (a -> ([a], b) -> b) -> b -> [a] -> b


-- | 関数 <tt>foldr</tt> を用いて、関数 <tt>map f</tt> と <tt>filter p</tt> を定義してください
module Ch07.Ex03

-- | <tt>foldr</tt> を使った <tt>map f</tt> の定義
--   
--   <pre>
--   map f = foldr ((:) . f) []
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | <tt>foldr</tt> を使った <tt>filter p</tt> の定義
--   
--   <pre>
--   filter p = foldr φ []
--     where
--       φ x xs
--         | p x       = x:xs
--         | otherwise = xs
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]


-- | <tt>foldl</tt> を用いて，十進表記を整数に変換する関数 <tt>dec2int :: [Int] -&gt; Int</tt>
--   を定義してください．
module Ch07.Ex04

-- | 十進表記を整数に変換する関数
--   
--   <pre>
--   &gt;&gt;&gt; dec2int [2,3,4,5]
--   2345
--   </pre>
dec2int :: [Int] -> Int


-- | プレリュードの定義を見ないで以下の二つの高階関数を定義してください．
--   
--   a. 「引数に組を取る関数」を「カリー化された関数」へ変換する関数 <tt>curry</tt> b.
--   「引数が二つのカリー化された関数」を「引数に組を取る関数」へ変換する関数 <tt>uncurry</tt>
module Ch07.Ex05

-- | 「引数に組を取る関数」を「カリー化された関数」へ変換する関数
--   
--   <pre>
--   curry :: ((a, b) -&gt; c) -&gt; a -&gt; b -&gt; c
--   curry f x y = f (x, y)
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | 「引数が二つのカリー化された関数」を「引数に組を取る関数」へ変換する関数
--   
--   <pre>
--   uncurry :: (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c
--   uncurry f = f . fst <a>*</a> snd
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c


-- | 関数 <tt>unfold :: (a -&gt; Bool) -&gt; (a -&gt; b) -&gt; (a -&gt; a)
--   -&gt; a -&gt; [b]</tt> を用いて関数 <tt>chop8</tt>，<tt>map
--   f</tt>，<tt>iterate f</tt> を再定義してください．
module Ch07.Ex06

-- | リスト上の unfold
--   
--   <pre>
--   &gt;&gt;&gt; unfold (== 0) (`mod` 2) (`div` 2) 13
--   [1,0,1,1]
--   </pre>
unfold :: (a -> Bool) -> (a -> b) -> (a -> a) -> a -> [b]
type Bit = Int

-- | ビットリストを8ビットの二進表記に分割する
--   
--   <pre>
--   chop8 = unfold null (take 8) (drop 8)
--   </pre>
chop8 :: [Bit] -> [[Bit]]

-- | <tt>unfold</tt>を用いた<tt>map f</tt>の定義
--   
--   <pre>
--   map f = unfold null (f . head) tail
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | <tt>unfold</tt>を用いた<tt>iterate f</tt>の定義
--   
--   <pre>
--   iterate f = unfold (const False) id f
--   </pre>
iterate :: (a -> a) -> a -> [a]


-- | パリティービットの概念を用いて，文字列の二進数への変換器が単純な通信エラーを検出できるように改良してください．
--   具体的には，符号化で生成された 8 ビットの二進数に， 1 の数が奇数なら 1 ，そうでないなら 0 になるパリティービットを付加します．
--   逆に復号の際は 9 ビットの二進数のパリティービットが正しいかを検査し，正しければパリティービットを捨て，
--   誤りであればパリティーエラーを報告するようにします。
module Ch07.Ex07

-- | 型変換 Word8 → Int
byte2int :: Word8 -> Int

-- | 型変換 Int → Word8
int2byte :: Int -> Word8

-- | IntからBit列へ変換
int2bin :: Int -> [Bit]

-- | Bit列からIntへ変換
bin2int :: [Bit] -> Int

-- | 指定した幅にBit列を調整
make :: Int -> [Bit] -> [Bit]

-- | 文字列をBit列に符号
encode :: String -> [Bit]

-- | Bit列を文字列に復号
decode :: [Bit] -> String

-- | 指定したビット数のビット列に分解
chop :: Int -> [Bit] -> [[Bit]]

-- | 文字列をBit列に符号した上で，8bitごとにチェックビット1ビット追加
--   
--   <pre>
--   &gt;&gt;&gt; send "吾輩は猫である"
--   [1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,1,1,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,0,0,1]
--   </pre>
send :: String -> [Bit]

-- | ビット列をチェックビットをチェックした上で，文字列に復号
--   
--   <pre>
--   &gt;&gt;&gt; recv (send "吾輩は猫である") == "吾輩は猫である"
--   True
--   </pre>
recv :: [Bit] -> String

-- | 通信路
transmit :: [Bit] -> [Bit]

-- | チェックビット
checkBit :: [Bit] -> Bit

-- | チェックビットの追加
addCB :: [Bit] -> [Bit]

-- | チェックビットでビット列を検査
check :: [Bit] -> Bool

-- | ビット列のチェック
chkCB :: [Bit] -> [Bit]


-- | 通信エラーの生じる通信路を用いて，直前の問題で定義した文字列を通信するプログラムを試してください．
--   この通信路は最初のビットを落とすものとします．
module Ch07.Ex08

-- | エラーのない伝送路での実験
--   
--   <pre>
--   experiment0 = putStrLn (recv (transmit (send "吾輩は猫である")))
--   transmit = id
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; catch experiment0 (\ e -&gt; hPutStrLn stderr (show (e :: SomeException)))
--   吾輩は猫である
--   </pre>
experiment0 :: IO ()

-- | 最初のビットが落ちる伝送路での実験
--   
--   <pre>
--   experiment1 = putStrLn (recv (transmit' (send "吾輩は猫である")))
--   transmit' = tail
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; catch experiment1 (\ e -&gt; const (putStrLn "エラーが起きました") (e :: SomeException))
--   エラーが起きました
--   </pre>
experiment1 :: IO ()
transmit' :: [Bit] -> [Bit]


-- | 関数 <tt>altMap :: (a -&gt; b) -&gt; (a -&gt; b) -&gt; [a] -&gt;
--   [b]</tt> を定義してください． この関数は，引数で指定された二つの関数をリストの要素に交互に適用します．
module Ch07.Ex09

-- | 引数で指定された二つの関数をリストの要素に交互に適用
--   
--   <pre>
--   &gt;&gt;&gt; altMap (+10) (+100) [0,1,2,3,4]
--   [10,101,12,103,14]
--   </pre>
altMap :: (a -> b) -> (a -> b) -> [a] -> [b]


-- | 第4章の練習問題に出てきた Luhn アルゴリズムを実装する関数を任意の長さのカード番号を取り扱えるように改良してください．
--   そのために，<tt>altMap</tt> を用いて関数 <tt>luhn :: [Int] -&gt; Bool</tt>
--   を定義してください．
module Ch07.Ex10

-- | Luhnアルゴリズム
--   
--   <pre>
--   &gt;&gt;&gt; luhn [0,1,2,3,4,5,6,7,8,9]
--   False
--   
--   &gt;&gt;&gt; luhn [0,1,2,3,4,5,6,7,8,2]
--   True
--   </pre>
luhn :: [Int] -> Bool


-- | 関数 <tt>add</tt> と同様に自然数の乗算関数 <tt>mult :: Nat -&gt; Nat -&gt; Nat</tt>
--   を再帰的に定義してください．
module Ch08.Ex01
data Nat
Zero :: Nat
Succ :: Nat -> Nat
add :: Nat -> Nat -> Nat

-- | Nat 上の乗算
--   
--   <pre>
--   mult Zero n     = Zero
--   mult (Succ m) n = add n (mult m n)
--   </pre>
mult :: Nat -> Nat -> Nat


-- | <tt>compare</tt>メソッドを用いて，探索木用の関数 <tt>occurs :: Ord a =&gt; a -&gt;
--   Tree a -&gt; Bool</tt> を再定義してください
module Ch08.Ex02

-- | 二分探索木
data Tree a
Leaf :: a -> Tree a
Node :: Tree a -> a -> Tree a -> Tree a

-- | 出現判定
--   
--   <pre>
--   occurs x (Leaf y) = x == y
--   occurs x (Node l y r) = case compare x y of
--     LT -&gt; occurs x l
--     EQ -&gt; True
--     GT -&gt; occurs x r
--   </pre>
--   
--   元の実装は1つのノードで x と y の比較が 2 回になる場合があるが， 新しい実装では 1 回ですむ．
occurs :: Ord a => a -> Tree a -> Bool


-- | 以下の二分木を考えましょう．
--   
--   <pre>
--   data Tree a = Leaf a | Node (Tree a) (Tree a)
--   </pre>
--   
--   すべての節に対して，右と左の部分木にある葉の数が高々一つだけ異なるとき，木は平衡していると呼びます．
--   葉は平衡していると考えます．二分木が平衡しているか調べる関数 <tt>balanced :: Tree a -&gt; Bool</tt>
--   を定義してください
module Ch08.Ex03

-- | 二分木
data Tree a
Leaf :: a -> Tree a
Node :: Tree a -> Tree a -> Tree a

-- | 葉の数
--   
--   <pre>
--   leaves (Leaf _) = 1
--   leaves (Node l r) = leaves l + leaves r
--   </pre>
leaves :: Tree a -> Int

-- | 葉の数(平衡でない部分木では0)
--   
--   <pre>
--   leaves' (Leaf _) = 1
--   leaves' (Node l r)
--     = case leaves' l of
--         0 -&gt; 0
--         m -&gt; case leaves' r of
--           0 -&gt; 0
--           n -&gt; bool 0 (m + n) (abs (m - n) &lt;= 1)
--   </pre>
leaves' :: (Num p, Ord p) => Tree a -> p

-- | 平衡判定
--   
--   <pre>
--   balanced = (/= 0) . leaves' 
--   </pre>
balanced :: Tree a -> Bool


-- | 空でない整数のリストを平衡木に変換する関数 <tt>balance :: [a] -&gt; Tree a</tt> を定義してください
module Ch08.Ex04

-- | リストを2分割
--   
--   <pre>
--   &gt;&gt;&gt; halve [1,2,3,4,5]
--   ([1,2,3],[4,5])
--   </pre>
halve :: [a] -> ([a], [a])

-- | 平衡木の生成
--   
--   <pre>
--   &gt;&gt;&gt; balance [1,2,3,4,5]
--   Node (Node (Node (Leaf 1) (Leaf 2)) (Leaf 3)) (Node (Leaf 4) (Leaf 5))
--   
--   &gt;&gt;&gt; balanced (balance [1,2,3,4,5,6,7])
--   True
--   </pre>
balance :: [a] -> Tree a
(***) :: (a -> c) -> (b -> d) -> (a, b) -> (c, d)
instance GHC.Show.Show a => GHC.Show.Show (Ch08.Ex03.Tree a)


module Ch08.Ex05

-- | 式
data Expr
Val :: Int -> Expr
Add :: Expr -> Expr -> Expr

-- | 式の畳み込み
--   
--   <pre>
--   folde f g e = case e of
--     Val x     -&gt; f x
--     Add e1 e2 -&gt; g (folde f g e1) (folde f g e2)
--   </pre>
folde :: (Int -> a) -> (a -> a -> a) -> Expr -> a
instance GHC.Show.Show Ch08.Ex05.Expr


module Ch08.Ex06

-- | 評価器
--   
--   <pre>
--   eval = folde id (+)
--   </pre>
eval :: Expr -> Int

-- | 式のサイズ
--   
--   <pre>
--   size = folde (const 1) (+)
--   </pre>
size :: Expr -> Int


-- | <pre>
--   instance Eq a =&gt; Eq (Maybe a) where
--     Nothing == Nothing = True
--     Just x  == Just y  = x == y
--     _       == _       = False
--   </pre>
--   
--   <pre>
--   instance Eq a =&gt; Eq [a] where
--     []     == []     = True
--     (x:xs) == (y:ys) = x == y &amp;&amp; xs == ys
--     _      == _      = False
--   </pre>
module Ch08.Ex07


module Ch08.Ex08

-- | 命題
data Prop
Const :: Bool -> Prop
Var :: Char -> Prop
Not :: Prop -> Prop
And :: Prop -> Prop -> Prop
Or :: Prop -> Prop -> Prop
Imply :: Prop -> Prop -> Prop
Equiv :: Prop -> Prop -> Prop

-- | 命題1
--   
--   <pre>
--   &gt;&gt;&gt; p1
--   And (Var 'A') (Not (Var 'A'))
--   </pre>
p1 :: Prop

-- | 命題2
--   
--   <pre>
--   &gt;&gt;&gt; p2
--   Imply (And (Var 'A') (Var 'B')) (Var 'A')
--   </pre>
p2 :: Prop

-- | 命題3
--   
--   <pre>
--   &gt;&gt;&gt; p3
--   Imply (Var 'A') (And (Var 'A') (Var 'B'))
--   </pre>
p3 :: Prop

-- | 命題4
--   
--   <pre>
--   &gt;&gt;&gt; p4
--   Imply (And (Var 'A') (Imply (Var 'A') (Var 'B'))) (Var 'B')
--   </pre>
p4 :: Prop

-- | 置換表
type Assoc a b = [(a, b)]
find :: Eq k => k -> Assoc k v -> v
type Subst = Assoc Char Bool
eval :: Subst -> Prop -> Bool

-- | 変数の出現リスト
--   
--   <pre>
--   &gt;&gt;&gt; vars p2 == ['A','B','A']
--   True
--   </pre>
vars :: Prop -> [Char]

-- | 指定した長さの真理値リスト
--   
--   <pre>
--   &gt;&gt;&gt; bools 3
--   [[False,False,False],[False,False,True],[False,True,False],[False,True,True],[True,False,False],[True,False,True],[True,True,False],[True,True,True]]
--   </pre>
bools :: Int -> [[Bool]]

-- | 置換リスト
--   
--   <pre>
--   &gt;&gt;&gt; substs p2
--   [[('A',False),('B',False)],[('A',False),('B',True)],[('A',True),('B',False)],[('A',True),('B',True)]]
--   </pre>
substs :: Prop -> [Subst]
rmdups :: Eq a => [a] -> [a]

-- | 恒真検査器
--   
--   <pre>
--   &gt;&gt;&gt; isTaut p1
--   False
--   
--   &gt;&gt;&gt; isTaut p2
--   True
--   
--   &gt;&gt;&gt; isTaut p3
--   False
--   
--   &gt;&gt;&gt; isTaut p4
--   True
--   
--   &gt;&gt;&gt; p5 = Or p1 (Not p1)
--   
--   &gt;&gt;&gt; isTaut p5
--   True
--   
--   &gt;&gt;&gt; p6 = Equiv p1 p3
--   
--   &gt;&gt;&gt; isTaut p6
--   False
--   </pre>
isTaut :: Prop -> Bool
instance GHC.Show.Show Ch08.Ex08.Prop
instance GHC.Classes.Eq Ch08.Ex08.Prop


module Ch08.Ex09

-- | 式
data Expr
Val :: Int -> Expr
Add :: Expr -> Expr -> Expr
Mul :: Expr -> Expr -> Expr
type Cont = [Op]

-- | 命令
data Op
EVAL :: Expr -> Op
ADD :: Int -> Op
MUL :: Int -> Op

-- | 評価器
eval :: Expr -> Cont -> Int

-- | 実行器
exec :: Cont -> Int -> Int

-- | 式の値
--   
--   <pre>
--   &gt;&gt;&gt; value (Add (Add (Val 2) (Val 3)) (Val 4))
--   9
--   
--   &gt;&gt;&gt; value (Mul (Add (Val 2) (Val 3)) (Val 4))
--   20
--   </pre>
value :: Expr -> Int
instance GHC.Show.Show Ch08.Ex09.Expr
instance GHC.Classes.Eq Ch08.Ex09.Expr

module Ch09.CountDown

-- | 算術演算子
data Op
Add :: Op
Sub :: Op
Mul :: Op
Div :: Op

-- | 適正な算術演算か
valid :: Op -> Int -> Int -> Bool

-- | 適正な算術演算の適用
apply :: Op -> Int -> Int -> Int

-- | 数式
data Expr
Val :: Int -> Expr
App :: Op -> Expr -> Expr -> Expr

-- | 式に含まれる数値のリスト
values :: Expr -> [Int]

-- | 評価器
--   
--   <pre>
--   &gt;&gt;&gt; eval (App Add (Val 2) (Val 3))
--   [5]
--   
--   &gt;&gt;&gt; eval (App Sub (Val 2) (Val 3))
--   []
--   </pre>
eval :: Expr -> [Int]

-- | 部分リスト
--   
--   <pre>
--   &gt;&gt;&gt; subs [1,2,3]
--   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
--   </pre>
subs :: [a] -> [[a]]

-- | 要素の挿入
--   
--   <pre>
--   &gt;&gt;&gt; interleave 1 [2,3,4]
--   [[1,2,3,4],[2,1,3,4],[2,3,1,4],[2,3,4,1]]
--   </pre>
interleave :: a -> [a] -> [[a]]

-- | 要素の順列
--   
--   <pre>
--   &gt;&gt;&gt; perms [1,2,3]
--   [[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]
--   </pre>
perms :: [a] -> [[a]]

-- | 選択肢の生成
--   
--   <pre>
--   &gt;&gt;&gt; choices [1,2,3]
--   [[],[3],[2],[2,3],[3,2],[1],[1,3],[3,1],[1,2],[2,1],[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]
--   </pre>
choices :: [a] -> [[a]]

-- | 解判定
--   
--   <pre>
--   &gt;&gt;&gt; e = App Mul (App Add (Val 1) (Val 50)) (App Sub (Val 25) (Val 10))
--   
--   &gt;&gt;&gt; e
--   (1+50)*(25-10)
--   
--   &gt;&gt;&gt; solution e [1,3,7,10,25,50] 765
--   True
--   </pre>
solution :: Expr -> [Int] -> Int -> Bool

-- | 空でないリストの空でない分割
--   
--   <pre>
--   &gt;&gt;&gt; split [1,2,3,4]
--   [([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4])]
--   </pre>
split :: [a] -> [([a], [a])]

-- | 与えられた数が一回だけ使われている式の生成
exprs :: [Int] -> [Expr]

-- | 演算子による組み合わせ
combine :: Expr -> Expr -> [Expr]

-- | 算術演算子のリスト
ops :: [Op]

-- | 解となる式の選択
--   
--   <pre>
--   &gt;&gt;&gt; length (solutions [1,3,7,10,25,50] 765)
--   780
--   </pre>
solutions :: [Int] -> Int -> [Expr]

-- | 結果の型
type Result = (Expr, Int)

-- | 与えられた数がそれぞれ一回だけ使われていうる式をすべて返す関数
results :: [Int] -> [Result]

-- | 結果の組み合わせ
combine' :: Result -> Result -> [Result]

-- | 解の選択
solutions' :: [Int] -> Int -> [Expr]

-- | 新しい valid
valid' :: Integral a => Op -> a -> a -> Bool

-- | 新しい valid を使った combine
combine'' :: Result -> Result -> [Result]

-- | 新しい combine を使った results
results' :: [Int] -> [Result]

-- | 速い solutions
solutions'' :: [Int] -> Int -> [Expr]
instance GHC.Show.Show Ch09.CountDown.Expr
instance GHC.Show.Show Ch09.CountDown.Op


-- | 関数合成 <tt>concat</tt> および <tt>map</tt> の代わりにリスト内包表記を使って，組み合わせの関数
--   <tt>choices</tt> を再定義してください．
module Ch09.Ex01

-- | 選択肢の生成
--   
--   <pre>
--   choices xs = [ zs | ys &lt;- subs xs, zs &lt;- perms ys ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; choices [1,2,3]
--   [[],[3],[2],[2,3],[3,2],[1],[1,3],[3,1],[1,2],[2,1],[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]
--   </pre>
choices :: [a] -> [[a]]


-- | 再帰的な関数 <tt>isChoice :: Eq a =&gt; [a] -&gt; [a] -&gt; Bool</tt>
--   を定義してください． この関数は <tt>perms</tt> や <tt>subs</tt>
--   を使わずに，一方のリストが他方のリストから選択されたものかを検査します．
module Ch09.Ex02

-- | 最初に見つけた特定の要素をリストから取り除く
removeone :: Eq a => a -> [a] -> [a]

-- | 一方が他方のリストから選択さたものかをチェックする
isChoice :: Eq a => [a] -> [a] -> Bool


-- | 関数 <tt>split</tt> を拡張して，組の中に空リストも許すようにすると，関数 <tt>solutions</tt>
--   の挙動にどのような影響を与えるか説明してください．
--   
--   <pre>
--   exprs :: [Int] -&gt; [Expr]
--   exprs []  = []
--   exprs [n] = [Val n]
--   exprs ns  = [ e | (ls, rs) &lt;- split ns
--                   , l        &lt;- exprs ls     -- *
--                   , r        &lt;- exprs rs     -- *
--                   , e        &lt;- combine l r
--              ]
--   </pre>
--   
--   expr が停止するためには * のところの再帰で，リストが短くなることが保証されなければならないが， split
--   で空リストを許すとその対は元のリストと同じリストになるために，再帰でリストが短くならない． 実際 expr は停止しなくなる．
module Ch09.Ex03


-- | 関数 <tt>choices</tt>，<tt>exprs</tt>，<tt>eval</tt> を用いて，1，3，7，1，25，50
--   に対する可能な式は 33,665,406 個あり，そのうち 4,672,540 個のみが有効であることを確 かめてください
module Ch09.Ex04


-- | 関数 <tt>choices</tt>，<tt>exprs</tt>，<tt>eval</tt> を用いて，1，3，7，1，25，50
--   に対する可能な式は 33,665,406 個あり，そのうち 4,672,540 個のみが有効であることを確 かめてください
module Ch09.Ex05

-- | 評価器
--   
--   <pre>
--   &gt;&gt;&gt; length [ e | ns' &lt;- choices ns, e &lt;- exprs ns', _ &lt;- eval e ]
--   10839369
--   </pre>
eval :: Expr -> [Int]

-- | Validator
--   
--   <pre>
--   valid Add x y = True
--   valid Sub x y = True
--   valid Mul x y = True
--   valid Div x y = y /= 0 &amp;&amp; x <a>mod</a> y == 0
--   </pre>
valid :: Op -> Int -> Int -> Bool


-- | リスト内包表記とプレリュード関数 <tt>sequence_ :: [IO a] -&gt; IO ()</tt>
--   を用いて，<tt>putStr :: String -&gt; IO ()</tt> を再定義してください．
module Ch10.Ex01

-- | 再定義した <tt>putStr</tt>
--   
--   <pre>
--   putStr cs = sequence_ [ putChar c | c &lt;- cs ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStr "Hello, world!\n"
--   Hello, world!
--   </pre>
putStr :: String -> IO ()


-- | 指定した数だけキーボードから数字を読み取り，それらの和を表示する <tt>adder :: IO ()</tt> を定義してください．
module Ch10.Ex04

-- | 加算器
--   
--   <pre>
--   adder
--   </pre>
--   
--   How many numbers? 5 1 3 5 7 9 The total is 25
adder :: IO ()

-- | 補助関数
adder' :: Int -> Int -> IO ()


module Ch10.Ex05

-- | 加算器（再実装）
--   
--   <pre>
--   adder
--   </pre>
--   
--   How many numbers? 5 1 3 5 7 9 The total is 25
adder :: IO ()
getInt :: IO Int

module Ch10.Hangman
hangman :: IO ()
sgetLine :: IO String
getCh :: IO Char
play :: String -> IO ()
match :: String -> String -> String


-- | getCh を用いて，アクション <tt>readLine :: IO String</tt> を定義してください．
--   このアクションは，<tt>getLine</tt> に似ていますが，文字を消すために消去キーが利用できます．
module Ch10.Ex06

-- | 消去キーが使える readLine
--   
--   <pre>
--   readLine = do
--     ibuf &lt;- hGetBuffering stdin
--     obuf &lt;- hGetBuffering stdout
--     hSetBuffering stdin NoBuffering
--     hSetBuffering stdout NoBuffering
--     str &lt;- loop ""
--     hSetBuffering stdin ibuf
--     hSetBuffering stdout obuf
--     return str
--   </pre>
readLine :: IO String

-- | readLine の下請け
--   
--   <pre>
--   loop xs = do
--     c &lt;- getCh
--     case c of
--       '\n'   -&gt; do putChar c
--                    return (reverse xs)
--       '\DEL' -&gt; case xs of
--          ""    -&gt; loop xs
--          _     -&gt; do putChar '\b'
--                      putChar ' '
--                      putChar '\b'
--                      loop (tail xs)
--       _      -&gt; do putChar c
--                    loop (c:xs)
--   </pre>
loop :: String -> IO String

module Ch10.LifeGame

-- | 画面クリア
cls :: IO ()

-- | 文字の位置
type Pos = (Int, Int)

-- | 位置指定書き込み
writeat :: Pos -> String -> IO ()
goto :: Pos -> IO ()

-- | ボードの幅
width :: Int

-- | ボードの高さ
height :: Int

-- | ボード
type Board = [Pos]

-- | グライダ
glider :: Board

-- | ボードの表示
showcells :: Board -> IO ()

-- | 生きているセルか
isAlive :: Board -> Pos -> Bool

-- | 空のセルか
isEmpty :: Board -> Pos -> Bool

-- | 近傍
neighbs :: Pos -> [Pos]

-- | ボードの端を連結（トーラスに）する
wrap :: Pos -> Pos

-- | 生きた近傍セルの数
liveneighbs :: Board -> Pos -> Int

-- | 次世代に生き残るセル
survivors :: Board -> [Pos]

-- | 新たに誕生するセル
births :: Board -> [Pos]

-- | 重複の除去
rmdups :: Eq a => [a] -> [a]

-- | 次の世代
nextgen :: Board -> Board

-- | ライフゲームの駆動
life :: Board -> IO ()

-- | 待機
wait :: Int -> IO ()

module Ch10.Nim

-- | 次のプレイヤー
next :: Int -> Int

-- | ボード
type Board = [Int]

-- | 初期ボード
initial :: Board

-- | 終了判定
finished :: Board -> Bool

-- | 有効性判定
valid :: Board -> Int -> Int -> Bool

-- | 打ち手
move :: Board -> Int -> Int -> Board

-- | 行の表示
putRow :: Int -> Int -> IO ()

-- | ボードの表示
putBoard :: Board -> IO ()

-- | 数字の取得
getDigit :: String -> IO Int

-- | 改行
newline :: IO ()

-- | ニムプレイ
play :: Board -> Int -> IO ()

-- | ニム
nim :: IO ()


-- | リスト内包表記と <tt>sequence_</tt> を使って，<tt>putBoard</tt> の拡張版を再実装してください．
module Ch10.Ex03

-- | ボードの表示
--   
--   <pre>
--   &gt;&gt;&gt; putBoard initial
--   1: * * * * * 
--   2: * * * * 
--   3: * * * 
--   4: * * 
--   5: * 
--   </pre>
putBoard :: Board -> IO ()


module Ch10.Ex02

-- | 任意の大きさのボードの表示
--   
--   <pre>
--   &gt;&gt;&gt; putBoard initial
--   1: * * * * * 
--   2: * * * * 
--   3: * * * 
--   4: * * 
--   5: * 
--   </pre>
putBoard :: Board -> IO ()
putBoard' :: Int -> Board -> IO ()

module Ch11.TicTacToe

-- | 格子サイズ
size :: Int

-- | 格子
type Grid = [[Player]]

-- | プレイヤ
data Player
O :: Player
B :: Player
X :: Player

-- | 次のプレイヤ
next :: Player -> Player

-- | 空の格子
empty :: Grid

-- | 充蜜の判定
full :: Grid -> Bool

-- | 次のターン
--   
--   <pre>
--   &gt;&gt;&gt; turn empty
--   O
--   </pre>
turn :: Grid -> Player

-- | 勝利判定
wins :: Player -> Grid -> Bool

-- | 対角線上のプレイヤ
diag :: Grid -> [Player]

-- | 勝者の存在判定
won :: Grid -> Bool
putGrid :: Grid -> IO ()

-- | 行の表示文字列リスト
showRow :: [Player] -> [String]

-- | プレイヤの値を文字列のリストに変換する
showPlayer :: Player -> [String]

-- | リストの要素の間に指定の要素を挟みこむ
interleave :: a -> [a] -> [a]

-- | 手の有効性判定
valid :: Grid -> Int -> Bool

-- | 指し手
move :: Grid -> Int -> Player -> [Grid]

-- | リストの断片化
chop :: Int -> [a] -> [[a]]

-- | プレイヤの指し手を読み込む
getNat :: String -> IO Int

-- | 三目並べ
tictactoe :: IO ()

-- | 起動
run :: Grid -> Player -> IO ()

-- | 駆動
run' :: Grid -> Player -> IO ()
prompt :: Player -> String

-- | 木
data Tree a
Node :: a -> [Tree a] -> Tree a

-- | ゲーム木
gametree :: Grid -> Player -> Tree Grid
moves :: Grid -> Player -> [Grid]

-- | 枝刈り
prune :: Int -> Tree a -> Tree a

-- | ゲーム木の深さ上限
depth :: Int

-- | minimax木
minimax :: Tree Grid -> Tree (Grid, Player)

-- | 最善手の選択
bestmove :: Grid -> Player -> Grid

-- | 人間対コンピュータ
main :: IO ()

-- | 起動
play :: Grid -> Player -> IO ()

-- | 駆動
play' :: Grid -> Player -> IO ()
instance GHC.Show.Show a => GHC.Show.Show (Ch11.TicTacToe.Tree a)
instance GHC.Show.Show Ch11.TicTacToe.Player
instance GHC.Classes.Ord Ch11.TicTacToe.Player
instance GHC.Classes.Eq Ch11.TicTacToe.Player


-- | 最終的なプログラムでは，必ず最善手のリストから初手を選択していました． <tt>System.Random</tt>
--   モジュールが提供する関数 <tt>randomRIO :: (Int,Int) -&gt; IO Int</tt>
--   を用いて，最善手をランダムに選ぶように変更してください． 関数 <tt>randomRIO</tt>
--   は与えられた範囲の中でランダムな整数を生成します．
module Ch11.Ex03

-- | 最善手
bestmove :: Grid -> Player -> Grid

-- | 木の深さ
treedepth :: Tree a -> Int

-- | 起動
play :: Grid -> Player -> IO ()

-- | 駆動
play' :: Grid -> Player -> IO ()
main :: IO ()


-- | 最終的なプログラムでは，必ず最善手のリストから初手を選択していました． <tt>System.Random</tt>
--   モジュールが提供する関数 <tt>randomRIO :: (Int,Int) -&gt; IO Int</tt>
--   を用いて，最善手をランダムに選ぶように変更してください． 関数 <tt>randomRIO</tt>
--   は与えられた範囲の中でランダムな整数を生成します．
module Ch11.Ex02

-- | 駆動
bestmove' :: Grid -> Player -> IO Grid


-- | 3 x 3 の三目並べを空の格子から始めると，完全なゲームの木の節の数が 549,946 になることを 関数
--   <tt>gametree</tt> を使って確かめましょう．また，木の最大の深さが 9 であることを確認してください．
module Ch11.Ex01

-- | 節の数
--   
--   <pre>
--   &gt;&gt;&gt; nodes (gametree empty O)
--   549946
--   </pre>
nodes :: Tree a -> Int

-- | 木の深さ &gt;&gt;&gt; depth (gametree empty O) 9
depth :: Tree a -> Int

module Lib

-- | 「なんか関数」を標準出力に印字する &gt;&gt;&gt; someFunc なんか関数
someFunc :: IO ()

-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/nobsun/pih2ed#readme</a>
@package pih2ed
@version 0.2.5.0


-- | <tt>double (double)</tt> の結果を算出する別の計算方法を考えましょう．
module Ch01Ex01

-- | 式
data Term
Num :: Int -> Term
Double :: Term -> Term
Add :: Term -> Term -> Term

-- | 簡約系列
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ print (redSeqs sample)
--   [double (double 2),(double 2) + (double 2),(2 + 2) + (double 2),4 + (double 2),4 + (2 + 2),4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(2 + 2) + (double 2),(2 + 2) + (2 + 2),4 + (2 + 2),4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(2 + 2) + (double 2),(2 + 2) + (2 + 2),(2 + 2) + 4,4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(double 2) + (2 + 2),(2 + 2) + (2 + 2),4 + (2 + 2),4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(double 2) + (2 + 2),(2 + 2) + (2 + 2),(2 + 2) + 4,4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(double 2) + (2 + 2),(double 2) + 4,(2 + 2) + 4,4 + 4,8]
--   [double (double 2),double (2 + 2),(2 + 2) + (2 + 2),4 + (2 + 2),4 + 4,8]
--   [double (double 2),double (2 + 2),(2 + 2) + (2 + 2),(2 + 2) + 4,4 + 4,8]
--   [double (double 2),double (2 + 2),double 4,4 + 4,8]
--   </pre>
redSeqs :: Term -> [[Term]]

-- | 1ステップ簡約
--   
--   <pre>
--   &gt;&gt;&gt; print (step sample)
--   [(double 2) + (double 2),double (2 + 2)]
--   </pre>
step :: Term -> [Term]
instance GHC.Show.Show Ch01Ex01.Term


-- | <tt>x</tt> の値によらず <tt>sum [x] = x</tt> であることを示してください．
module Ch01Ex02

-- | リストの要素の和
--   
--   <pre>
--   sum []     = 0           -- (1)
--   sum (n:ns) = n + sum ns  -- (2)
--   
--   </pre>
--   
--   <pre>
--   sum [x]
--   = { [x] ≡ (x:[]) }
--   sum (x:[])
--   = { sumの定義(2) }
--   x + sum []
--   = { sumの定義(1) }
--   x + 0
--   = { 0 は + の単位元 }
--   x
--   
--   </pre>
sum :: Num p => [p] -> p


-- | 数値のリストに対し積を計算する関数 <tt>product</tt> を定義し，<tt>product [2,3,4]</tt> =
--   <tt>24</tt> であることを示してください．
module Ch01Ex03

-- | リストの要素の和
--   
--   <pre>
--   product []     = 1           -- (1)
--   product (n:ns) = n * sum ns  -- (2)
--   
--   </pre>
--   
--   <pre>
--   product [2,3,4]
--   = { [2,3,4] = (2:[3,4]) }
--   product (2:[3,4])
--   = { product の定義(2) }
--   2 * product [3,4]
--   = { [3,4] = (3:[4]) }
--   2 * product (3:[4])
--   = { product の定義(2) }
--   2 * (3 * product [4])
--   = { [4] = (4:[]) }
--   2 * (3 * product (4:[]))
--   = { product の定義(2) }
--   2 * (3 * (4 * product []))
--   = { product の定義(1) }
--   2 * (3 * (4 * 1))
--   = { 4 * 1 = 4 }
--   2 * (3 * 4)
--   = { 3 * 4 = 12 }
--   2 * 12
--   = { 2 * 12 = 12 }
--   24
--   
--   </pre>
product :: Num p => [p] -> p


-- | リストを降順に整列するように関数<tt>qsort</tt>の定義を変えるにはどうすればよいでしょうか？
module Ch01Ex04

-- | 降順に整列
--   
--   <pre>
--   qsort []     = []                                    -- (1)
--   qsort (x:xs) = qsort larger ++ [x] ++ qsort smaller  -- (2) qsort smaller と qsort larger を交換
--     where
--       smaller = [a | a &lt;- xs, a &lt;= x]
--       larger  = [b | b <a>xs, b</a> x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; qsort [3,5,1,4,2]
--   [5,4,3,2,1]
--   </pre>
qsort :: Ord a => [a] -> [a]


-- | <tt>qsort</tt>の定義で，<tt>&lt;=</tt> を <tt>&lt;</tt>
--   に置き換えるとどのような影響があるでしょうか？
module Ch01Ex05

-- | <pre>
--   qsort []     = []                                    -- (1)
--   qsort (x:xs) = qsort smaller ++ [x] ++ qsort larger  -- (2)
--     where
--       smaller = [a | a &lt;- xs, a &lt; x] -- <tt>&lt;=</tt> を <tt>&lt;</tt> に置き換える
--       larger  = [b | b <a>xs, b</a> x]
--   </pre>
--   
--   <tt>qsort</tt>の定義で，<tt>&lt;=</tt> を <tt>&lt;</tt>
--   に置き換えると，ピボットとと同値のピボット以外の要素を落してしまうことになる．
--   
--   <pre>
--   &gt;&gt;&gt; qsort [2,2,3,1,1]
--   [1,2,3]
--   </pre>
qsort :: Ord a => [a] -> [a]


-- | この章の例題をGHCiを用いて実行してください
module Ch02Ex01


-- | 次の式に結合順位を示す括弧を付けてください．
module Ch02Ex02


-- | 以下のプログラムにはエラーが三つあります．エラーを修正してGHCiで正しく動くか確かめてください．
module Ch02Ex03

-- | プログラムの修正
--   
--   <pre>
--   N =  a <a>div</a> length xs     -- (1)変数名は小文字アルファベット．(2)関数<tt>div</tt>を中置演算子に変更するには<tt>`</tt>で囲む．
--        where
--            a = 10
--           xs = [1,2,3,4,5]   -- (3)同一レベルのバインディングでは左辺のインデント位置を同じにする．
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; n
--   2
--   </pre>
n :: Int


-- | プレリュード関数 <tt>last</tt> は，空でないリストの最後の要素を取り出します． たとえば，<tt>last
--   [1,2,3,4,5]</tt> = <tt>5</tt> です． この章で紹介したプレリュード関数を使って，関数
--   <tt>last</tt> を定義してください． さらに別の定義も考えてみてください．
module Ch02Ex04

-- | <tt>last</tt> の定義
--   
--   <pre>
--   last' (x:[]) = x
--   last' (_:xs) = last' xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last' [1,2,3,4,5]
--   5
--   </pre>
last' :: () => [p] -> p

-- | もう一つの <tt>last</tt> の定義
--   
--   <pre>
--   last'' = head . reverse
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last'' [1,2,3,4,5]
--   5
--   </pre>
last'' :: () => [c] -> c


-- | プレリュード関数 <tt>init</tt> は，空でないリストから最後の要素を取り除きます． たとえば，<tt>init
--   [1,2,3,4,5]</tt> = <tt>[1,2,3,4]</tt> です．関数 <tt>init</tt>
--   の定義を二通り示してください．
module Ch02Ex05

-- | <tt>init</tt> の一つめの定義
--   
--   <pre>
--   init' (x:[]) = []
--   init' (x:xs) = x : init' xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init' [1,2,3,4,5]
--   [1,2,3,4]
--   </pre>
init' :: () => [a] -> [a]

-- | <tt>init</tt> のもう一つの定義
--   
--   <pre>
--   init'' = reverse . tail . reverse
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init'' [1,2,3,4,5]
--   [1,2,3,4]
--   </pre>
init'' :: () => [a] -> [a]


-- | プレリュード関数 @<tt> は，空でないリストの最後の要素を取り出します． たとえば，</tt>last [1,2,3,4,5]<tt>
--   = </tt>5<tt> です． この章で紹介したプレリュード関数を使って，関数 </tt>last@ を定義してください．
--   さらに別の定義も考えてみてください．
module Ch03Ex01

-- | <tt>init</tt> の一つめの定義
--   
--   <pre>
--   init' (x:[]) = []
--   init' (x:xs) = x : init' xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init' [1,2,3,4,5]
--   [1,2,3,4]
--   </pre>
init' :: () => [a] -> [a]

-- | <tt>init</tt> のもう一つの定義
--   
--   <pre>
--   init'' = reverse . tail . reverse
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init'' [1,2,3,4,5]
--   [1,2,3,4]
--   </pre>
init'' :: () => [a] -> [a]

module Lib

-- | 「なんか関数」を標準出力に印字する &gt;&gt;&gt; someFunc なんか関数
someFunc :: IO ()

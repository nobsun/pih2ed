-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/nobsun/pih2ed#readme</a>
@package pih2ed
@version 0.5.6.0


-- | <tt>double (double)</tt> の結果を算出する別の計算方法を考えましょう．
module Ch01Ex01

-- | 式
data Term
Num :: Int -> Term
Double :: Term -> Term
Add :: Term -> Term -> Term

-- | 簡約系列
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ print (redSeqs sample)
--   [double (double 2),(double 2) + (double 2),(2 + 2) + (double 2),4 + (double 2),4 + (2 + 2),4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(2 + 2) + (double 2),(2 + 2) + (2 + 2),4 + (2 + 2),4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(2 + 2) + (double 2),(2 + 2) + (2 + 2),(2 + 2) + 4,4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(double 2) + (2 + 2),(2 + 2) + (2 + 2),4 + (2 + 2),4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(double 2) + (2 + 2),(2 + 2) + (2 + 2),(2 + 2) + 4,4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(double 2) + (2 + 2),(double 2) + 4,(2 + 2) + 4,4 + 4,8]
--   [double (double 2),double (2 + 2),(2 + 2) + (2 + 2),4 + (2 + 2),4 + 4,8]
--   [double (double 2),double (2 + 2),(2 + 2) + (2 + 2),(2 + 2) + 4,4 + 4,8]
--   [double (double 2),double (2 + 2),double 4,4 + 4,8]
--   </pre>
redSeqs :: Term -> [[Term]]

-- | 1ステップ簡約
--   
--   <pre>
--   &gt;&gt;&gt; print (step sample)
--   [(double 2) + (double 2),double (2 + 2)]
--   </pre>
step :: Term -> [Term]
instance GHC.Show.Show Ch01Ex01.Term


-- | <tt>x</tt> の値によらず <tt>sum [x] = x</tt> であることを示してください．
module Ch01Ex02

-- | リストの要素の和
--   
--   <pre>
--   sum []     = 0           -- (1)
--   sum (n:ns) = n + sum ns  -- (2)
--   
--   </pre>
--   
--   <pre>
--   sum [x]
--   = { [x] ≡ (x:[]) }
--   sum (x:[])
--   = { sumの定義(2) }
--   x + sum []
--   = { sumの定義(1) }
--   x + 0
--   = { 0 は + の単位元 }
--   x
--   
--   </pre>
sum :: Num p => [p] -> p


-- | 数値のリストに対し積を計算する関数 <tt>product</tt> を定義し，<tt>product [2,3,4]</tt> =
--   <tt>24</tt> であることを示してください．
module Ch01Ex03

-- | リストの要素の和
--   
--   <pre>
--   product []     = 1           -- (1)
--   product (n:ns) = n * sum ns  -- (2)
--   
--   </pre>
--   
--   <pre>
--   product [2,3,4]
--   = { [2,3,4] = (2:[3,4]) }
--   product (2:[3,4])
--   = { product の定義(2) }
--   2 * product [3,4]
--   = { [3,4] = (3:[4]) }
--   2 * product (3:[4])
--   = { product の定義(2) }
--   2 * (3 * product [4])
--   = { [4] = (4:[]) }
--   2 * (3 * product (4:[]))
--   = { product の定義(2) }
--   2 * (3 * (4 * product []))
--   = { product の定義(1) }
--   2 * (3 * (4 * 1))
--   = { 4 * 1 = 4 }
--   2 * (3 * 4)
--   = { 3 * 4 = 12 }
--   2 * 12
--   = { 2 * 12 = 12 }
--   24
--   
--   </pre>
product :: Num p => [p] -> p


-- | リストを降順に整列するように関数<tt>qsort</tt>の定義を変えるにはどうすればよいでしょうか？
module Ch01Ex04

-- | 降順に整列
--   
--   <pre>
--   qsort []     = []                                    -- (1)
--   qsort (x:xs) = qsort larger ++ [x] ++ qsort smaller  -- (2) qsort smaller と qsort larger を交換
--     where
--       smaller = [a | a &lt;- xs, a &lt;= x]
--       larger  = [b | b <a>xs, b</a> x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; qsort [3,5,1,4,2]
--   [5,4,3,2,1]
--   </pre>
qsort :: Ord a => [a] -> [a]


-- | <tt>qsort</tt>の定義で，<tt>&lt;=</tt> を <tt>&lt;</tt>
--   に置き換えるとどのような影響があるでしょうか？
module Ch01Ex05

-- | <pre>
--   qsort []     = []                                    -- (1)
--   qsort (x:xs) = qsort smaller ++ [x] ++ qsort larger  -- (2)
--     where
--       smaller = [a | a &lt;- xs, a &lt; x] -- <tt>&lt;=</tt> を <tt>&lt;</tt> に置き換える
--       larger  = [b | b <a>xs, b</a> x]
--   </pre>
--   
--   <tt>qsort</tt>の定義で，<tt>&lt;=</tt> を <tt>&lt;</tt>
--   に置き換えると，ピボットとと同値のピボット以外の要素を落してしまうことになる．
--   
--   <pre>
--   &gt;&gt;&gt; qsort [2,2,3,1,1]
--   [1,2,3]
--   </pre>
qsort :: Ord a => [a] -> [a]


-- | この章の例題をGHCiを用いて実行してください
module Ch02Ex01


-- | 次の式に結合順位を示す括弧を付けてください．
module Ch02Ex02


-- | 以下のプログラムにはエラーが三つあります．エラーを修正してGHCiで正しく動くか確かめてください．
module Ch02Ex03

-- | プログラムの修正
--   
--   <pre>
--   N =  a <a>div</a> length xs     -- (1)変数名は小文字アルファベット．(2)関数<tt>div</tt>を中置演算子に変更するには<tt>`</tt>で囲む．
--        where
--            a = 10
--           xs = [1,2,3,4,5]   -- (3)同一レベルのバインディングでは左辺のインデント位置を同じにする．
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; n
--   2
--   </pre>
n :: Int


-- | プレリュード関数 <tt>last</tt> は，空でないリストの最後の要素を取り出します． たとえば，<tt>last
--   [1,2,3,4,5]</tt> = <tt>5</tt> です． この章で紹介したプレリュード関数を使って，関数
--   <tt>last</tt> を定義してください． さらに別の定義も考えてみてください．
module Ch02Ex04

-- | <tt>last</tt> の定義
--   
--   <pre>
--   last' (x:[]) = x
--   last' (_:xs) = last' xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last' [1,2,3,4,5]
--   5
--   </pre>
last' :: () => [p] -> p

-- | もう一つの <tt>last</tt> の定義
--   
--   <pre>
--   last'' = head . reverse
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last'' [1,2,3,4,5]
--   5
--   </pre>
last'' :: () => [c] -> c


-- | プレリュード関数 <tt>init</tt> は，空でないリストから最後の要素を取り除きます． たとえば，<tt>init
--   [1,2,3,4,5]</tt> = <tt>[1,2,3,4]</tt> です．関数 <tt>init</tt>
--   の定義を二通り示してください．
module Ch02Ex05

-- | <tt>init</tt> の一つめの定義
--   
--   <pre>
--   init' (x:[]) = []
--   init' (x:xs) = x : init' xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init' [1,2,3,4,5]
--   [1,2,3,4]
--   </pre>
init' :: () => [a] -> [a]

-- | <tt>init</tt> のもう一つの定義
--   
--   <pre>
--   init'' = reverse . tail . reverse
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init'' [1,2,3,4,5]
--   [1,2,3,4]
--   </pre>
init'' :: () => [a] -> [a]


-- | 以下の値の型は何でしょう?
--   
--   <pre>
--   <a>'a','b','c'</a>
--   [(False,'0'),(True,'1')]
--   ([False,True],['0','1'])
--   [tail, init, reverse]
--   </pre>
module Ch03Ex01


-- | 以下の関数の定義を書き下してください．型が正しい限り，どのように実装してもかまいません．
--   
--   <pre>
--   bools :: [Bool]
--   nums :: [[Int]]
--   add :: Int -&gt; Int -&gt; Int -&gt; Int
--   copy :: a -&gt; (a, a)
--   apply :: (a -&gt; b) -&gt; a -&gt; b
--   </pre>
module Ch03Ex02

-- | <pre>
--   &gt;&gt;&gt; :type bools
--   bools :: [Bool]
--   </pre>
bools :: [Bool]

-- | <pre>
--   &gt;&gt;&gt; :type nums
--   nums :: [[Int]]
--   </pre>
nums :: [[Int]]

-- | <pre>
--   &gt;&gt;&gt; :type add
--   add :: Int -&gt; Int -&gt; Int -&gt; Int
--   </pre>
add :: Int -> Int -> Int -> Int

-- | <pre>
--   &gt;&gt;&gt; :type copy
--   copy :: a -&gt; (a, a)
--   </pre>
copy :: a -> (a, a)

-- | <pre>
--   &gt;&gt;&gt; :type apply
--   apply :: (a -&gt; b) -&gt; a -&gt; b
--   </pre>
apply :: (a -> b) -> a -> b


-- | 以下の関数の型は何でしょう?
--   
--   <pre>
--   second xs = head (tail xs)
--   swap (x,y) = (y,x)
--   pair x y = (x,y)
--   double x = x*2
--   palindrome xs = reverse xs == xs
--   twice f x = f (f x)
--   </pre>
module Ch03Ex03

-- | <pre>
--   &gt;&gt;&gt; :type second
--   second :: [a] -&gt; a
--   </pre>
second :: [a] -> a

-- | <pre>
--   &gt;&gt;&gt; :type swap
--   swap :: (a, b) -&gt; (b, a)
--   </pre>
swap :: (a, b) -> (b, a)

-- | <pre>
--   &gt;&gt;&gt; :type pair
--   pair :: a -&gt; b -&gt; (a, b)
--   </pre>
pair :: a -> b -> (a, b)

-- | <pre>
--   &gt;&gt;&gt; :type double
--   double :: Num a =&gt; a -&gt; a
--   </pre>
double :: Num a => a -> a

-- | <pre>
--   &gt;&gt;&gt; :type palindrome
--   palindrome :: Eq a =&gt; [a] -&gt; Bool
--   </pre>
palindrome :: Eq a => [a] -> Bool

-- | <pre>
--   &gt;&gt;&gt; :type twice
--   twice :: (a -&gt; a) -&gt; a -&gt; a
--   </pre>
twice :: (a -> a) -> a -> a


-- | 上記三つの問題の答えを GHCi を使って確かめてください．
--   
--   <pre>
--   Ch03ex01.hs
--   Ch03ex02.hs
--   Ch03ex03.hs
--   </pre>
module Ch03Ex04


-- | 一般的に，関数の型を Eq クラスのインスタンスにするのが実現不可能な理由は何でしょうか? 実現可能なのはどういった場合でしょうか?
--   
--   関数の等値性は，外延的等値性を確認することになるが， 関数の域(domain)を網羅列挙して確認することは一般にはできない．
--   ただし，域が現実的に網羅列挙可能であれば Eq クラスのインスタンスにできる．
module Ch03Ex05


-- | プレリュード関数を使って，長さが偶数のリストを半分ずつに分割する関数 <tt>halve :: [a] -&gt; ([a],
--   [a])</tt> を定義してください．
module Ch04Ex01

-- | 長さ偶数のリストを半分ずつに分割する．
--   
--   <pre>
--   &gt;&gt;&gt; halve [1,2,3,4,5,6]
--   ([1,2,3],[4,5,6])
--   </pre>
halve :: [a] -> ([a], [a])


-- | リストの三つめの要素を返す関数 <tt>third :: [a] -&gt; a</tt> を以下を使ってそれぞれ定義してください．
--   ただし，リストには三つ以上の要素が格納されているとします．
--   
--   <ul>
--   <li>a. head と tail</li>
--   <li>b. リストのインデックス演算子 !!</li>
--   <li>c. パターンマッチ</li>
--   </ul>
module Ch04Ex02

-- | リストの三つめの要素 その1
--   
--   <pre>
--   third1 :: [a] -&gt; a
--   third1 = head . tail . tail
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; third1 [1,2,3,4,5,6]
--   3
--   </pre>
third1 :: [a] -> a

-- | リストの三つめの要素 その2
--   
--   <pre>
--   third2 :: [a] -&gt; a
--   third2 = (!! 2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; third2 [1,2,3,4,5,6]
--   3
--   </pre>
third2 :: [a] -> a

-- | リストの三つめの要素 その3
--   
--   <pre>
--   third3 :: [a] -&gt; a
--   third3 (_:_:x:_) = x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; third3 [1,2,3,4,5,6]
--   3
--   </pre>
third3 :: [a] -> a


-- | プレリュード関数 tail のように振る舞う safetail :: [a] -&gt; [a] 関数を考えてください．
--   ただし，<tt>tail</tt> は空リストを与えるとエラーになりますが， <tt>safetail</tt>
--   は空リストをエラーとせず，空リストを返すものとします．
--   
--   <ul>
--   <li>a. 条件式</li>
--   <li>b. ガード付きの等式</li>
--   <li>c. パターンマッチ</li>
--   </ul>
module Ch04Ex03

-- | 安全な <tt>tail</tt> その1
--   
--   <pre>
--   safetail1 :: [a] -&gt; [a]
--   safetail1 xs = if null xs then xs else tail xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safetail1 [1,2,3]
--   [2,3]
--   
--   &gt;&gt;&gt; safetail1 []
--   []
--   </pre>
safetail1 :: [a] -> [a]

-- | 安全な <tt>tail</tt> その2
--   
--   <pre>
--   safetail2 :: [a] -&gt; [a]
--   safetail2 xs
--     | null xs   = xs
--     | otherwise = tail xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safetail2 [1,2,3]
--   [2,3]
--   
--   &gt;&gt;&gt; safetail2 []
--   []
--   </pre>
safetail2 :: [a] -> [a]

-- | 安全な <tt>tail</tt> その3
--   
--   <pre>
--   safetail3 :: [a] -&gt; [a]
--   safetail3 []     = []
--   safetail3 (_:xs) = xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safetail3 [1,2,3]
--   [2,3]
--   
--   &gt;&gt;&gt; safetail3 []
--   []
--   </pre>
safetail3 :: [a] -> [a]


-- | 論理積演算子 &amp;&amp; と同様に，パターンマッチを使って論理和演算子 <tt>||</tt> を四通りの方法で定義してください．
module Ch04Ex04

-- | 1つめの定義
--   
--   <pre>
--   def1 :: Bool -&gt; Bool -&gt; Bool
--   def1 = (||)
--     where
--       False || False = False
--       False || True  = True
--       True  || False = True
--       True  || True  = True
--   </pre>
def1 :: Bool -> Bool -> Bool

-- | 2つめの定義
--   
--   <pre>
--   def2 :: Bool -&gt; Bool -&gt; Bool
--   def2 = (||)
--     where
--       False || False = False
--       _     || _     = True
--   </pre>
def2 :: Bool -> Bool -> Bool

-- | 3つめの定義
--   
--   <pre>
--   def3 :: Bool -&gt; Bool -&gt; Bool
--   def3 = (||)
--     where
--       False || b = b
--       True  || _ = True
--   </pre>
def3 :: Bool -> Bool -> Bool

-- | 4つめの定義
--   
--   <pre>
--   def4 :: Bool -&gt; Bool -&gt; Bool
--   def4 = (||)
--     where
--       False || b = b
--       True  || _ = True
--   </pre>
def4 :: Bool -> Bool -> Bool


-- | 他のプレリュード関数や演算子を使わずに，論理積 <tt>&amp;&amp;</tt>
--   に対する以下の定義を条件式を用いて形式化してください．
--   
--   <pre>
--   True &amp;&amp; True = True
--   _    &amp;&amp; _    = False
--   </pre>
module Ch04Ex05

-- | 連言の条件式を使った定式化
--   
--   <pre>
--   (&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool
--   p &amp;&amp; q = if p then if q then True else false else false
--   </pre>
(&&) :: Bool -> Bool -> Bool


-- | 他のプレリュード関数や演算子を使わずに，論理積 <tt>&amp;&amp;</tt>
--   に対する以下の定義を条件式を用いて形式化してください．
--   
--   <pre>
--   True  &amp;&amp; b = b
--   False &amp;&amp; _ = False
--   </pre>
module Ch04Ex06

-- | 連言の条件式を使った定式化
--   
--   <pre>
--   (&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool
--   p &amp;&amp; q = if p then q else False
--   </pre>
(&&) :: Bool -> Bool -> Bool


-- | 以下のカリー化された関数の定義の意味をラムダ式を用いて形式化してください．
--   
--   <pre>
--   mult :: Int -&gt; Int -&gt; Int -&gt; Int
--   mult x y z = x * y * z
--   </pre>
module Ch04Ex07

-- | 3つの整数の積
--   
--   <pre>
--   mult :: Int -&gt; Int -&gt; Int -&gt; Int
--   mult =  x -&gt;  y -&gt;  z -&gt; x * y * z
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mult 2 3 4
--   24
--   </pre>
mult :: Int -> Int -> Int -> Int


-- | Luhn アルゴリズム
--   
--   <ul>
--   <li>それぞれの桁を独立した数だとみなす</li>
--   <li>右から数えて偶数番めの数すべてを二倍にする</li>
--   <li>それぞれの数が 9 より大きいなら 9 を引く</li>
--   <li>すべての数を足し合わせる</li>
--   <li>合計が 10 で割り切れるなら、カードの番号は正しい</li>
--   </ul>
module Ch04Ex08

-- | 数を 2 倍にして、もしその結果が 9 より大きいなら 9 を引く関数
--   
--   <pre>
--   &gt;&gt;&gt; luhnDouble 3
--   6
--   
--   &gt;&gt;&gt; luhnDouble 6
--   3
--   </pre>
luhnDouble :: Int -> Int

-- | 4桁の銀行カード番号が正しいかどうかを判定する関数
--   
--   <pre>
--   &gt;&gt;&gt; luhn 1 7 8 4
--   True
--   
--   &gt;&gt;&gt; luhn 4 7 8 3
--   False
--   </pre>
luhn :: Int -> Int -> Int -> Int -> Bool


-- | リスト内包表記を使って， 1 から 100 までの二乗の和 1^2 + 2^2 + ... + 100^2 を計算する式を考えてください．
module Ch05Ex01

-- | 2乗の和
sumSquare :: [Int] -> Int


-- | m × n の座標格子が， 0 ≦ x ≦ m ， 0 ≦ y ≦ n に対し， すべての整数の組 (x, y) で表現されているとします．
--   リスト内包表記を一つ用いて，与えられた大きさの座標格子を返す関数 <tt>grid :: Int -&gt; Int -&gt;
--   [(Int,Int)]</tt> を定義してください．
module Ch05Ex02

-- | 格子点
--   
--   <pre>
--   &gt;&gt;&gt; grid 1 2
--   [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]
--   </pre>
grid :: Int -> Int -> [(Int, Int)]


-- | リスト内容表記一つと上記の関数 grid を用いて，大きさ n の正方形座標を 返す関数 square :: Int -&gt;
--   [(Int,Int)] を定義してください． ただし，(0, 0) から (n, n) の対角の格子は含みません．
module Ch05Ex03

-- | 対角格子を抜いた正方格子
--   
--   <pre>
--   &gt;&gt;&gt; square 2
--   [(0,1),(0,2),(1,0),(1,2),(2,0),(2,1)]
--   </pre>
square :: Int -> [(Int, Int)]
grid :: Int -> Int -> [(Int, Int)]


-- | ある要素のみからなるリストを生成するプレリュード関数 <tt>replicate :: Int -&gt; a -&gt; [a]</tt>
--   を関数 <tt>length</tt> と同じ要領でリスト内包表記を用いて定義してください.
module Ch05Ex04

-- | 同一要素を指定した個数含むリストの生成
--   
--   <pre>
--   &gt;&gt;&gt; replicate 3 True
--   [True,True,True]
--   </pre>
replicate :: Int -> a -> [a]


-- | <tt> x^2 + y^2 = z^2 </tt> を満たす正の整数をピタゴラス数と呼び，三つ組 <tt>(x, y, z)</tt>
--   で表します． ピタゴラス数のリストを生成する関数 <tt> pyths :: Int -&gt; [(Int, Int, Int)]
--   </tt>をリスト内包表記を使って定義してください． ただし、ピタゴラス数の要素は与えられた上限以下であるとします．
module Ch05Ex05

-- | ピタゴラス数
--   
--   <pre>
--   &gt;&gt;&gt; pyths 10
--   [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
--   </pre>
pyths :: Int -> [(Int, Int, Int)]


-- | 自分自身を除く約数の和が自分自身と等しいとき，その整数を完全数と呼びます． 与えられた上限までに含まれる完全数すべてを算出する関数
--   <tt>perfects :: Int -&gt; [Int]</tt> を リスト内包表記と関数 factors
--   を使って定義してください．
module Ch05Ex06

-- | 完全数
--   
--   <pre>
--   &gt;&gt;&gt; perfects 500
--   [6,28,496]
--   </pre>
perfects :: Int -> [Int]

-- | 素因数
factors :: Int -> [Int]

module Lib

-- | 「なんか関数」を標準出力に印字する &gt;&gt;&gt; someFunc なんか関数
someFunc :: IO ()

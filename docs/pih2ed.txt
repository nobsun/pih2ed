-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/nobsun/pih2ed#readme</a>
@package pih2ed
@version 0.6.5.0


-- | <tt>double (double)</tt> の結果を算出する別の計算方法を考えましょう．
module Ch01.Ex01

-- | 式
data Term
Num :: Int -> Term
Double :: Term -> Term
Add :: Term -> Term -> Term

-- | 簡約系列
--   
--   <pre>
--   &gt;&gt;&gt; mapM_ print (redSeqs sample)
--   [double (double 2),(double 2) + (double 2),(2 + 2) + (double 2),4 + (double 2),4 + (2 + 2),4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(2 + 2) + (double 2),(2 + 2) + (2 + 2),4 + (2 + 2),4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(2 + 2) + (double 2),(2 + 2) + (2 + 2),(2 + 2) + 4,4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(double 2) + (2 + 2),(2 + 2) + (2 + 2),4 + (2 + 2),4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(double 2) + (2 + 2),(2 + 2) + (2 + 2),(2 + 2) + 4,4 + 4,8]
--   [double (double 2),(double 2) + (double 2),(double 2) + (2 + 2),(double 2) + 4,(2 + 2) + 4,4 + 4,8]
--   [double (double 2),double (2 + 2),(2 + 2) + (2 + 2),4 + (2 + 2),4 + 4,8]
--   [double (double 2),double (2 + 2),(2 + 2) + (2 + 2),(2 + 2) + 4,4 + 4,8]
--   [double (double 2),double (2 + 2),double 4,4 + 4,8]
--   </pre>
redSeqs :: Term -> [[Term]]

-- | 1ステップ簡約
--   
--   <pre>
--   &gt;&gt;&gt; print (step sample)
--   [(double 2) + (double 2),double (2 + 2)]
--   </pre>
step :: Term -> [Term]
instance GHC.Show.Show Ch01.Ex01.Term


-- | <tt>x</tt> の値によらず <tt>sum [x] = x</tt> であることを示してください．
module Ch01.Ex02

-- | リストの要素の和
--   
--   <pre>
--   sum []     = 0           -- (1)
--   sum (n:ns) = n + sum ns  -- (2)
--   
--   </pre>
--   
--   <pre>
--   sum [x]
--   = { [x] ≡ (x:[]) }
--   sum (x:[])
--   = { sumの定義(2) }
--   x + sum []
--   = { sumの定義(1) }
--   x + 0
--   = { 0 は + の単位元 }
--   x
--   
--   </pre>
sum :: Num p => [p] -> p


-- | 数値のリストに対し積を計算する関数 <tt>product</tt> を定義し，<tt>product [2,3,4]</tt> =
--   <tt>24</tt> であることを示してください．
module Ch01.Ex03

-- | リストの要素の和
--   
--   <pre>
--   product []     = 1           -- (1)
--   product (n:ns) = n * sum ns  -- (2)
--   
--   </pre>
--   
--   <pre>
--   product [2,3,4]
--   = { [2,3,4] = (2:[3,4]) }
--   product (2:[3,4])
--   = { product の定義(2) }
--   2 * product [3,4]
--   = { [3,4] = (3:[4]) }
--   2 * product (3:[4])
--   = { product の定義(2) }
--   2 * (3 * product [4])
--   = { [4] = (4:[]) }
--   2 * (3 * product (4:[]))
--   = { product の定義(2) }
--   2 * (3 * (4 * product []))
--   = { product の定義(1) }
--   2 * (3 * (4 * 1))
--   = { 4 * 1 = 4 }
--   2 * (3 * 4)
--   = { 3 * 4 = 12 }
--   2 * 12
--   = { 2 * 12 = 12 }
--   24
--   
--   </pre>
product :: Num p => [p] -> p


-- | リストを降順に整列するように関数<tt>qsort</tt>の定義を変えるにはどうすればよいでしょうか？
module Ch01.Ex04

-- | 降順に整列
--   
--   <pre>
--   qsort []     = []                                    -- (1)
--   qsort (x:xs) = qsort larger ++ [x] ++ qsort smaller  -- (2) qsort smaller と qsort larger を交換
--     where
--       smaller = [a | a &lt;- xs, a &lt;= x]
--       larger  = [b | b <a>xs, b</a> x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; qsort [3,5,1,4,2]
--   [5,4,3,2,1]
--   </pre>
qsort :: Ord a => [a] -> [a]


-- | <tt>qsort</tt>の定義で，<tt>&lt;=</tt> を <tt>&lt;</tt>
--   に置き換えるとどのような影響があるでしょうか？
module Ch01.Ex05

-- | <pre>
--   qsort []     = []                                    -- (1)
--   qsort (x:xs) = qsort smaller ++ [x] ++ qsort larger  -- (2)
--     where
--       smaller = [a | a &lt;- xs, a &lt; x] -- <tt>&lt;=</tt> を <tt>&lt;</tt> に置き換える
--       larger  = [b | b <a>xs, b</a> x]
--   </pre>
--   
--   <tt>qsort</tt>の定義で，<tt>&lt;=</tt> を <tt>&lt;</tt>
--   に置き換えると，ピボットとと同値のピボット以外の要素を落してしまうことになる．
--   
--   <pre>
--   &gt;&gt;&gt; qsort [2,2,3,1,1]
--   [1,2,3]
--   </pre>
qsort :: Ord a => [a] -> [a]


-- | この章の例題をGHCiを用いて実行してください
module Ch02.Ex01


-- | 次の式に結合順位を示す括弧を付けてください．
module Ch02.Ex02


-- | 以下のプログラムにはエラーが三つあります．エラーを修正してGHCiで正しく動くか確かめてください．
module Ch02.Ex03

-- | プログラムの修正
--   
--   <pre>
--   N =  a <a>div</a> length xs     -- (1)変数名は小文字アルファベット．(2)関数<tt>div</tt>を中置演算子に変更するには<tt>`</tt>で囲む．
--        where
--            a = 10
--           xs = [1,2,3,4,5]   -- (3)同一レベルのバインディングでは左辺のインデント位置を同じにする．
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; n
--   2
--   </pre>
n :: Int


-- | プレリュード関数 <tt>last</tt> は，空でないリストの最後の要素を取り出します． たとえば，<tt>last
--   [1,2,3,4,5]</tt> = <tt>5</tt> です． この章で紹介したプレリュード関数を使って，関数
--   <tt>last</tt> を定義してください． さらに別の定義も考えてみてください．
module Ch02.Ex04

-- | <tt>last</tt> の定義
--   
--   <pre>
--   last' (x:[]) = x
--   last' (_:xs) = last' xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last' [1,2,3,4,5]
--   5
--   </pre>
last' :: () => [p] -> p

-- | もう一つの <tt>last</tt> の定義
--   
--   <pre>
--   last'' = head . reverse
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; last'' [1,2,3,4,5]
--   5
--   </pre>
last'' :: () => [c] -> c


-- | プレリュード関数 <tt>init</tt> は，空でないリストから最後の要素を取り除きます． たとえば，<tt>init
--   [1,2,3,4,5]</tt> = <tt>[1,2,3,4]</tt> です．関数 <tt>init</tt>
--   の定義を二通り示してください．
module Ch02.Ex05

-- | <tt>init</tt> の一つめの定義
--   
--   <pre>
--   init' (x:[]) = []
--   init' (x:xs) = x : init' xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init' [1,2,3,4,5]
--   [1,2,3,4]
--   </pre>
init' :: () => [a] -> [a]

-- | <tt>init</tt> のもう一つの定義
--   
--   <pre>
--   init'' = reverse . tail . reverse
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init'' [1,2,3,4,5]
--   [1,2,3,4]
--   </pre>
init'' :: () => [a] -> [a]


-- | 以下の値の型は何でしょう?
--   
--   <pre>
--   <a>'a','b','c'</a>
--   [(False,'0'),(True,'1')]
--   ([False,True],['0','1'])
--   [tail, init, reverse]
--   </pre>
module Ch03.Ex01


-- | 以下の関数の定義を書き下してください．型が正しい限り，どのように実装してもかまいません．
--   
--   <pre>
--   bools :: [Bool]
--   nums :: [[Int]]
--   add :: Int -&gt; Int -&gt; Int -&gt; Int
--   copy :: a -&gt; (a, a)
--   apply :: (a -&gt; b) -&gt; a -&gt; b
--   </pre>
module Ch03.Ex02

-- | <pre>
--   &gt;&gt;&gt; :type bools
--   bools :: [Bool]
--   </pre>
bools :: [Bool]

-- | <pre>
--   &gt;&gt;&gt; :type nums
--   nums :: [[Int]]
--   </pre>
nums :: [[Int]]

-- | <pre>
--   &gt;&gt;&gt; :type add
--   add :: Int -&gt; Int -&gt; Int -&gt; Int
--   </pre>
add :: Int -> Int -> Int -> Int

-- | <pre>
--   &gt;&gt;&gt; :type copy
--   copy :: a -&gt; (a, a)
--   </pre>
copy :: a -> (a, a)

-- | <pre>
--   &gt;&gt;&gt; :type apply
--   apply :: (a -&gt; b) -&gt; a -&gt; b
--   </pre>
apply :: (a -> b) -> a -> b


-- | 以下の関数の型は何でしょう?
--   
--   <pre>
--   second xs = head (tail xs)
--   swap (x,y) = (y,x)
--   pair x y = (x,y)
--   double x = x*2
--   palindrome xs = reverse xs == xs
--   twice f x = f (f x)
--   </pre>
module Ch03.Ex03

-- | <pre>
--   &gt;&gt;&gt; :type second
--   second :: [a] -&gt; a
--   </pre>
second :: [a] -> a

-- | <pre>
--   &gt;&gt;&gt; :type swap
--   swap :: (a, b) -&gt; (b, a)
--   </pre>
swap :: (a, b) -> (b, a)

-- | <pre>
--   &gt;&gt;&gt; :type pair
--   pair :: a -&gt; b -&gt; (a, b)
--   </pre>
pair :: a -> b -> (a, b)

-- | <pre>
--   &gt;&gt;&gt; :type double
--   double :: Num a =&gt; a -&gt; a
--   </pre>
double :: Num a => a -> a

-- | <pre>
--   &gt;&gt;&gt; :type palindrome
--   palindrome :: Eq a =&gt; [a] -&gt; Bool
--   </pre>
palindrome :: Eq a => [a] -> Bool

-- | <pre>
--   &gt;&gt;&gt; :type twice
--   twice :: (a -&gt; a) -&gt; a -&gt; a
--   </pre>
twice :: (a -> a) -> a -> a


-- | 上記三つの問題の答えを GHCi を使って確かめてください．
--   
--   <pre>
--   Ch03ex01.hs
--   Ch03ex02.hs
--   Ch03ex03.hs
--   </pre>
module Ch03.Ex04


-- | 一般的に，関数の型を Eq クラスのインスタンスにするのが実現不可能な理由は何でしょうか? 実現可能なのはどういった場合でしょうか?
--   
--   関数の等値性は，外延的等値性を確認することになるが， 関数の域(domain)を網羅列挙して確認することは一般にはできない．
--   ただし，域が現実的に網羅列挙可能であれば Eq クラスのインスタンスにできる．
module Ch03.Ex05


-- | プレリュード関数を使って，長さが偶数のリストを半分ずつに分割する関数 <tt>halve :: [a] -&gt; ([a],
--   [a])</tt> を定義してください．
module Ch04.Ex01

-- | 長さ偶数のリストを半分ずつに分割する．
--   
--   <pre>
--   &gt;&gt;&gt; halve [1,2,3,4,5,6]
--   ([1,2,3],[4,5,6])
--   </pre>
halve :: [a] -> ([a], [a])


-- | リストの三つめの要素を返す関数 <tt>third :: [a] -&gt; a</tt> を以下を使ってそれぞれ定義してください．
--   ただし，リストには三つ以上の要素が格納されているとします．
--   
--   <ul>
--   <li>a. head と tail</li>
--   <li>b. リストのインデックス演算子 !!</li>
--   <li>c. パターンマッチ</li>
--   </ul>
module Ch04.Ex02

-- | リストの三つめの要素 その1
--   
--   <pre>
--   third1 :: [a] -&gt; a
--   third1 = head . tail . tail
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; third1 [1,2,3,4,5,6]
--   3
--   </pre>
third1 :: [a] -> a

-- | リストの三つめの要素 その2
--   
--   <pre>
--   third2 :: [a] -&gt; a
--   third2 = (!! 2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; third2 [1,2,3,4,5,6]
--   3
--   </pre>
third2 :: [a] -> a

-- | リストの三つめの要素 その3
--   
--   <pre>
--   third3 :: [a] -&gt; a
--   third3 (_:_:x:_) = x
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; third3 [1,2,3,4,5,6]
--   3
--   </pre>
third3 :: [a] -> a


-- | プレリュード関数 tail のように振る舞う safetail :: [a] -&gt; [a] 関数を考えてください．
--   ただし，<tt>tail</tt> は空リストを与えるとエラーになりますが， <tt>safetail</tt>
--   は空リストをエラーとせず，空リストを返すものとします．
--   
--   <ul>
--   <li>a. 条件式</li>
--   <li>b. ガード付きの等式</li>
--   <li>c. パターンマッチ</li>
--   </ul>
module Ch04.Ex03

-- | 安全な <tt>tail</tt> その1
--   
--   <pre>
--   safetail1 :: [a] -&gt; [a]
--   safetail1 xs = if null xs then xs else tail xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safetail1 [1,2,3]
--   [2,3]
--   
--   &gt;&gt;&gt; safetail1 []
--   []
--   </pre>
safetail1 :: [a] -> [a]

-- | 安全な <tt>tail</tt> その2
--   
--   <pre>
--   safetail2 :: [a] -&gt; [a]
--   safetail2 xs
--     | null xs   = xs
--     | otherwise = tail xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safetail2 [1,2,3]
--   [2,3]
--   
--   &gt;&gt;&gt; safetail2 []
--   []
--   </pre>
safetail2 :: [a] -> [a]

-- | 安全な <tt>tail</tt> その3
--   
--   <pre>
--   safetail3 :: [a] -&gt; [a]
--   safetail3 []     = []
--   safetail3 (_:xs) = xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; safetail3 [1,2,3]
--   [2,3]
--   
--   &gt;&gt;&gt; safetail3 []
--   []
--   </pre>
safetail3 :: [a] -> [a]


-- | 論理積演算子 &amp;&amp; と同様に，パターンマッチを使って論理和演算子 <tt>||</tt> を四通りの方法で定義してください．
module Ch04.Ex04

-- | 1つめの定義
--   
--   <pre>
--   def1 :: Bool -&gt; Bool -&gt; Bool
--   def1 = (||)
--     where
--       False || False = False
--       False || True  = True
--       True  || False = True
--       True  || True  = True
--   </pre>
def1 :: Bool -> Bool -> Bool

-- | 2つめの定義
--   
--   <pre>
--   def2 :: Bool -&gt; Bool -&gt; Bool
--   def2 = (||)
--     where
--       False || False = False
--       _     || _     = True
--   </pre>
def2 :: Bool -> Bool -> Bool

-- | 3つめの定義
--   
--   <pre>
--   def3 :: Bool -&gt; Bool -&gt; Bool
--   def3 = (||)
--     where
--       False || b = b
--       True  || _ = True
--   </pre>
def3 :: Bool -> Bool -> Bool

-- | 4つめの定義
--   
--   <pre>
--   def4 :: Bool -&gt; Bool -&gt; Bool
--   def4 = (||)
--     where
--       False || b = b
--       True  || _ = True
--   </pre>
def4 :: Bool -> Bool -> Bool


-- | 他のプレリュード関数や演算子を使わずに，論理積 <tt>&amp;&amp;</tt>
--   に対する以下の定義を条件式を用いて形式化してください．
--   
--   <pre>
--   True &amp;&amp; True = True
--   _    &amp;&amp; _    = False
--   </pre>
module Ch04.Ex05

-- | 連言の条件式を使った定式化
--   
--   <pre>
--   (&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool
--   p &amp;&amp; q = if p then if q then True else false else false
--   </pre>
(&&) :: Bool -> Bool -> Bool


-- | 他のプレリュード関数や演算子を使わずに，論理積 <tt>&amp;&amp;</tt>
--   に対する以下の定義を条件式を用いて形式化してください．
--   
--   <pre>
--   True  &amp;&amp; b = b
--   False &amp;&amp; _ = False
--   </pre>
module Ch04.Ex06

-- | 連言の条件式を使った定式化
--   
--   <pre>
--   (&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool
--   p &amp;&amp; q = if p then q else False
--   </pre>
(&&) :: Bool -> Bool -> Bool


-- | 以下のカリー化された関数の定義の意味をラムダ式を用いて形式化してください．
--   
--   <pre>
--   mult :: Int -&gt; Int -&gt; Int -&gt; Int
--   mult x y z = x * y * z
--   </pre>
module Ch04.Ex07

-- | 3つの整数の積
--   
--   <pre>
--   mult :: Int -&gt; Int -&gt; Int -&gt; Int
--   mult =  x -&gt;  y -&gt;  z -&gt; x * y * z
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mult 2 3 4
--   24
--   </pre>
mult :: Int -> Int -> Int -> Int


-- | Luhn アルゴリズム
--   
--   <ul>
--   <li>それぞれの桁を独立した数だとみなす</li>
--   <li>右から数えて偶数番めの数すべてを二倍にする</li>
--   <li>それぞれの数が 9 より大きいなら 9 を引く</li>
--   <li>すべての数を足し合わせる</li>
--   <li>合計が 10 で割り切れるなら、カードの番号は正しい</li>
--   </ul>
module Ch04.Ex08

-- | 数を 2 倍にして、もしその結果が 9 より大きいなら 9 を引く関数
--   
--   <pre>
--   &gt;&gt;&gt; luhnDouble 3
--   6
--   
--   &gt;&gt;&gt; luhnDouble 6
--   3
--   </pre>
luhnDouble :: Int -> Int

-- | 4桁の銀行カード番号が正しいかどうかを判定する関数
--   
--   <pre>
--   &gt;&gt;&gt; luhn 1 7 8 4
--   True
--   
--   &gt;&gt;&gt; luhn 4 7 8 3
--   False
--   </pre>
luhn :: Int -> Int -> Int -> Int -> Bool


-- | リスト内包表記を使って， 1 から 100 までの二乗の和 1^2 + 2^2 + ... + 100^2 を計算する式を考えてください．
module Ch05.Ex01

-- | 2乗の和
sumSquare :: [Int] -> Int


-- | m × n の座標格子が， 0 ≦ x ≦ m ， 0 ≦ y ≦ n に対し， すべての整数の組 (x, y) で表現されているとします．
--   リスト内包表記を一つ用いて，与えられた大きさの座標格子を返す関数 <tt>grid :: Int -&gt; Int -&gt;
--   [(Int,Int)]</tt> を定義してください．
module Ch05.Ex02

-- | 格子点
--   
--   <pre>
--   &gt;&gt;&gt; grid 1 2
--   [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]
--   </pre>
grid :: Int -> Int -> [(Int, Int)]


-- | リスト内容表記一つと上記の関数 grid を用いて，大きさ n の正方形座標を 返す関数 square :: Int -&gt;
--   [(Int,Int)] を定義してください． ただし，(0, 0) から (n, n) の対角の格子は含みません．
module Ch05.Ex03

-- | 対角格子を抜いた正方格子
--   
--   <pre>
--   &gt;&gt;&gt; square 2
--   [(0,1),(0,2),(1,0),(1,2),(2,0),(2,1)]
--   </pre>
square :: Int -> [(Int, Int)]
grid :: Int -> Int -> [(Int, Int)]


-- | ある要素のみからなるリストを生成するプレリュード関数 <tt>replicate :: Int -&gt; a -&gt; [a]</tt>
--   を関数 <tt>length</tt> と同じ要領でリスト内包表記を用いて定義してください.
module Ch05.Ex04

-- | 同一要素を指定した個数含むリストの生成
--   
--   <pre>
--   &gt;&gt;&gt; replicate 3 True
--   [True,True,True]
--   </pre>
replicate :: Int -> a -> [a]


-- | <tt> x^2 + y^2 = z^2 </tt> を満たす正の整数をピタゴラス数と呼び，三つ組 <tt>(x, y, z)</tt>
--   で表します． ピタゴラス数のリストを生成する関数 <tt> pyths :: Int -&gt; [(Int, Int, Int)]
--   </tt>をリスト内包表記を使って定義してください． ただし、ピタゴラス数の要素は与えられた上限以下であるとします．
module Ch05.Ex05

-- | ピタゴラス数
--   
--   <pre>
--   &gt;&gt;&gt; pyths 10
--   [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
--   </pre>
pyths :: Int -> [(Int, Int, Int)]


-- | 自分自身を除く約数の和が自分自身と等しいとき，その整数を完全数と呼びます． 与えられた上限までに含まれる完全数すべてを算出する関数
--   <tt>perfects :: Int -&gt; [Int]</tt> を リスト内包表記と関数 factors
--   を使って定義してください．
module Ch05.Ex06

-- | 完全数
--   
--   <pre>
--   &gt;&gt;&gt; perfects 500
--   [6,28,496]
--   </pre>
perfects :: Int -> [Int]

-- | 素因数
factors :: Int -> [Int]


-- | 二つの生成器を持つリスト内包表記 <tt>[(x, y) | x &lt;- [1, 2, 3], y &lt;- [4, 5,
--   6]]</tt> は， 一つの生成器を持つリスト内包表記二つでも表現できることを示してください．
module Ch05.Ex07


-- | 関数 <tt>positions</tt> を関数 <tt>find</tt> を使って再定義してください．
module Ch05.Ex08

-- | <tt>find</tt> を用いた <tt>positions</tt> の定義
--   
--   <pre>
--   positions :: Eq a =&gt; a -&gt; [a] -&gt; [Int]
--   positions x = find x . flip zip [0..]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; positions False [True, False, True, False]
--   [1,3]
--   </pre>
positions :: Eq a => a -> [a] -> [Int]
find :: Eq a => a -> [(a, b)] -> [b]


-- | 二つのリストから内積を計算する関数 <tt>scalarproduct :: [Int] -&gt; [Int] -&gt;
--   Int</tt> を 関数 <tt>chisqr</tt> と同じようにリスト内包表記を使って定義できることを示してください．
module Ch05.Ex09

-- | 内積
--   
--   <pre>
--   scalarproduct :: [Int] -&gt; [Int] -&gt; Int
--   scalarproduct xs ys = sum [ x * y | (x, y) &lt;- zip xs ys ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scalarproduct [1,2,3] [4,5,6]
--   32
--   </pre>
scalarproduct :: [Int] -> [Int] -> Int


-- | シーザー暗号のプログラムを変更して大文字も扱えるようにしてください．
module Ch05.Ex10

-- | 文字を整数に変換 'a' -&gt; 0，'b' -&gt; 1，... ，'A' -&gt; 26，'B' -&gt; 27
--   
--   <pre>
--   &gt;&gt;&gt; let2int 'a'
--   0
--   
--   &gt;&gt;&gt; let2int 'B'
--   27
--   </pre>
let2int :: Char -> Int

-- | 整数を文字に変換 0 -&gt; 'a'，1 -&gt; 'b'，...，26 -&gt; 'A'，27 -&gt; 'B'
--   
--   <pre>
--   &gt;&gt;&gt; int2let 1
--   'b'
--   
--   &gt;&gt;&gt; int2let 26
--   'A'
--   </pre>
int2let :: Int -> Char

-- | アルファベット文字シフト
--   
--   <pre>
--   &gt;&gt;&gt; shift 3 'a'
--   'd'
--   
--   &gt;&gt;&gt; shift 3 'z'
--   'c'
--   
--   &gt;&gt;&gt; shift (-3) 'c'
--   'z'
--   
--   &gt;&gt;&gt; shift 3 ' '
--   ' '
--   
--   &gt;&gt;&gt; shift 3 'A'
--   'D'
--   
--   &gt;&gt;&gt; shift 3 'Z'
--   'C'
--   
--   &gt;&gt;&gt; shift (-3) 'C'
--   'Z'
--   </pre>
shift :: Int -> Char -> Char

-- | 暗号
--   
--   <pre>
--   &gt;&gt;&gt; encode 3 "Haskell is fun"
--   "Kdvnhoo lv ixq"
--   
--   &gt;&gt;&gt; encode (-3) "Kdvnhoo lv ixq"
--   "Haskell is fun"
--   </pre>
encode :: Int -> String -> String


-- | 再帰的に定義された階乗関数は， (-1) のように負の整数を与えられた場合，どのように振る舞うでしょうか?
--   再帰部にガードを加えることで，負の整数を禁止するように定義を変更してください．
module Ch06.Ex01

-- | 階乗関数
--   
--   <pre>
--   fac :: Int -&gt; Int
--   fac 0 = 1
--   fac n | n &lt; 0     = error "<a>fac</a> must be applied to non-negative number"
--         | otherwise = n * fac (n - 1)
--   </pre>
fac :: Int -> Int


-- | 与えられた非負の整数から <tt>0</tt> までを足し合わせる関数 <tt>sumdown :: Int -&gt; Int </tt>
--   を再帰的に定義してください． たとえば，<tt>sumdown 3</tt> は <tt>3+2+1+0</tt> の結果
--   <tt>6</tt> を返します．
module Ch06.Ex02

-- | 与えられた非負の整数から <tt>0</tt> までを足し合わせる．
--   
--   <pre>
--   &gt;&gt;&gt; sumdown 3
--   6
--   </pre>
sumdown :: Int -> Int


-- | 乗算演算子 <tt>*</tt> の再帰を参考にして，負でない整数に対する冪乗演算子 <tt>^</tt> を定義
--   してください．また，その定義を使って <tt>2 ^ 3</tt> を簡約してください．
module Ch06.Ex03

-- | べき乗演算子
--   
--   <pre>
--   m ^ 0 = 1                  -- (1)
--   m ^ n = m * (m ^ (n - 1))  -- (2)
--   </pre>
--   
--   <pre>
--     2 ^ 3
--   = { (2) }
--     2 * (2 ^ 2)
--   = { (2) }
--     2 * (2 * (2 ^ 1))
--   = { (2) }
--     2 * (2 * (2 * (2 ^ 0)))
--   = { (1) }
--     2 * (2 * (2 * 1))
--   = { (*) }
--     2 * (2 * 2)
--   = { (*) }
--     2 * 4
--   = { (*) }
--     8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 ^ 3
--   8
--   </pre>
(^) :: Int -> Int -> Int
infixr 8 ^


-- | 二つの非負の整数に対する最大公約数を計算するために，ユークリッドの互除法を実現する関数 <tt> euclid :: Int -&gt;
--   Int -&gt; Int </tt> を再帰的に定義してください．
module Ch06.Ex04

-- | ユークリッド互除法
--   
--   <pre>
--   &gt;&gt;&gt; euclid 6 27
--   3
--   </pre>
euclid :: Int -> Int -> Int


-- | この章で与えられた再帰的定義を使って，<tt>length [1,2,3]</tt>，<tt>drop 3
--   [1,2,3,4,5]</tt>，<tt>init [1,2,3]</tt> を簡約してください．
module Ch06.Ex05

-- | リストの長さ <tt> length :: [a] -&gt; Int length [] = 0 -- (1) length (_:xs)
--   = 1 + length xs -- (2) </tt>
--   
--   <pre>
--     length [1,2,3]
--   = { (2) }
--     1 + (length [2,3])
--   = { (2) }
--     1 + (1 + (length [3]))
--   = { (2) }
--     1 + (1 + (1 + lenght []))
--   = { (1) }
--     1 + (1 + (1 + 0))
--   = { (+) }
--     1 + (1 + 1)
--   = { (+) }
--     1 + 2
--   = { (+) }
--     3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length [1,2,3]
--   3
--   </pre>
length :: [a] -> Int

-- | リストの先頭から指定した数の要素を落す
--   
--   <pre>
--   drop :: Int -&gt; [a] -&gt; [a]
--   drop 0 xs     = xs            -- (1)
--   drop _ []     = []            -- (2)
--   drop n (_:xs) = drop (n-1) xs -- (3)
--   </pre>
--   
--   <pre>
--     drop 3 [1,2,3,4,5]
--   = { (3) }
--     drop 2 [2,3,4,5]
--   = { (3) }
--     drop 1 [3,4,5]
--   = { (3) }
--     drop 0 [4,5]
--   = { (1) }
--     [4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; drop 3 [1,2,3,4,5]
--   [4,5]
--   </pre>
drop :: Int -> [a] -> [a]

-- | リストの先頭部分
--   
--   <pre>
--   init :: [a] -&gt; [a]
--   init [_]    = []          -- (1)
--   init (x:xs) = x : init xs -- (2)
--   </pre>
--   
--   <pre>
--     init [1,2,3]
--   = { (2) }
--     1 : init [2,3]
--   = { (2) }
--     1 : (2 : init [3])
--   = { (1) }
--     1 : (2 : [])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; init [1,2,3]
--   [1,2]
--   </pre>
init :: [a] -> [a]

module Lib

-- | 「なんか関数」を標準出力に印字する &gt;&gt;&gt; someFunc なんか関数
someFunc :: IO ()
